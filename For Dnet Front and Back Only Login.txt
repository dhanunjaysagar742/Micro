Spring Boot 3.5.5 JWT Authentication with Role-Based Access Control
Here's a complete implementation using your role table structure:

Project Structure
text
src/main/java/com/example/auth/
├── config/
│   ├── JwtAuthenticationEntryPoint.java
│   ├── JwtRequestFilter.java
│   └── SecurityConfig.java
├── controller/
│   ├── AuthController.java
│   └── UserController.java
├── dto/
│   ├── JwtRequest.java
│   ├── JwtResponse.java
│   └── UserDetailsDto.java
├── entity/
│   ├── Role.java
│   ├── UserRole.java
│   └── User.java
├── repository/
│   ├── RoleRepository.java
│   ├── UserRepository.java
│   └── UserRoleRepository.java
├── service/
│   ├── JwtUserDetailsService.java
│   ├── UserService.java
│   └── JwtUtil.java
└── AuthApplication.java
Dependencies (pom.xml)
xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.5.5</version>
        <relativePath/>
    </parent>
    
    <groupId>com.example</groupId>
    <artifactId>jwt-auth</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <packaging>jar</packaging>
    
    <properties>
        <java.version>21</java.version>
    </properties>
    
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>0.12.3</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>0.12.3</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>0.12.3</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>runtime</scope>
        </dependency>
    </dependencies>
</project>
Entity Classes
Role.java
java
package com.example.auth.entity;

import jakarta.persistence.*;

@Entity
@Table(name = "role")
public class Role {
    @Id
    @Column(name = "role_no")
    private Integer roleNo;
    
    @Column(name = "role_name", nullable = false)
    private String roleName;
    
    // Constructors
    public Role() {}
    
    public Role(Integer roleNo, String roleName) {
        this.roleNo = roleNo;
        this.roleName = roleName;
    }
    
    // Getters and Setters
    public Integer getRoleNo() { return roleNo; }
    public void setRoleNo(Integer roleNo) { this.roleNo = roleNo; }
    
    public String getRoleName() { return roleName; }
    public void setRoleName(String roleName) { this.roleName = roleName; }
}
UserRole.java
java
package com.example.auth.entity;

import jakarta.persistence.*;

@Entity
@Table(name = "user_role")
@IdClass(UserRoleId.class)
public class UserRole {
    @Id
    @Column(name = "empid")
    private Long empId;
    
    @Id
    @Column(name = "role_no")
    private Integer roleNo;
    
    @Id
    @Column(name = "directorate")
    private String directorate;
    
    @Column(name = "role_name")
    private String roleName;
    
    // Constructors
    public UserRole() {}
    
    public UserRole(Long empId, Integer roleNo, String roleName, String directorate) {
        this.empId = empId;
        this.roleNo = roleNo;
        this.roleName = roleName;
        this.directorate = directorate;
    }
    
    // Getters and Setters
    public Long getEmpId() { return empId; }
    public void setEmpId(Long empId) { this.empId = empId; }
    
    public Integer getRoleNo() { return roleNo; }
    public void setRoleNo(Integer roleNo) { this.roleNo = roleNo; }
    
    public String getRoleName() { return roleName; }
    public void setRoleName(String roleName) { this.roleName = roleName; }
    
    public String getDirectorate() { return directorate; }
    public void setDirectorate(String directorate) { this.directorate = directorate; }
}
UserRoleId.java
java
package com.example.auth.entity;

import java.io.Serializable;
import java.util.Objects;

public class UserRoleId implements Serializable {
    private Long empId;
    private Integer roleNo;
    private String directorate;
    
    public UserRoleId() {}
    
    public UserRoleId(Long empId, Integer roleNo, String directorate) {
        this.empId = empId;
        this.roleNo = roleNo;
        this.directorate = directorate;
    }
    
    // Getters, setters, equals, and hashCode
    public Long getEmpId() { return empId; }
    public void setEmpId(Long empId) { this.empId = empId; }
    
    public Integer getRoleNo() { return roleNo; }
    public void setRoleNo(Integer roleNo) { this.roleNo = roleNo; }
    
    public String getDirectorate() { return directorate; }
    public void setDirectorate(String directorate) { this.directorate = directorate; }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        UserRoleId that = (UserRoleId) o;
        return Objects.equals(empId, that.empId) && 
               Objects.equals(roleNo, that.roleNo) && 
               Objects.equals(directorate, that.directorate);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(empId, roleNo, directorate);
    }
}
User.java
java
package com.example.auth.entity;

import jakarta.persistence.*;

@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long empId;
    
    @Column(unique = true, nullable = false)
    private String username;
    
    @Column(nullable = false)
    private String password;
    
    @Column(nullable = false)
    private boolean enabled = true;
    
    // Constructors
    public User() {}
    
    public User(String username, String password) {
        this.username = username;
        this.password = password;
    }
    
    // Getters and Setters
    public Long getEmpId() { return empId; }
    public void setEmpId(Long empId) { this.empId = empId; }
    
    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }
    
    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }
    
    public boolean isEnabled() { return enabled; }
    public void setEnabled(boolean enabled) { this.enabled = enabled; }
}
Repository Interfaces
UserRepository.java
java
package com.example.auth.repository;

import com.example.auth.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
}
UserRoleRepository.java
java
package com.example.auth.repository;

import com.example.auth.entity.UserRole;
import com.example.auth.entity.UserRoleId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface UserRoleRepository extends JpaRepository<UserRole, UserRoleId> {
    List<UserRole> findByEmpId(Long empId);
}
RoleRepository.java
java
package com.example.auth.repository;

import com.example.auth.entity.Role;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface RoleRepository extends JpaRepository<Role, Integer> {
}
JWT Utility Class
JwtUtil.java
java
package com.example.auth.service;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;

@Component
public class JwtUtil {
    
    @Value("${jwt.secret:mySecretKey}")
    private String secret;
    
    @Value("${jwt.expiration:86400}")
    private int jwtExpiration;
    
    private SecretKey getSigningKey() {
        return Keys.hmacShaKeyFor(secret.getBytes());
    }
    
    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }
    
    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }
    
    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }
    
    private Claims extractAllClaims(String token) {
        return Jwts.parser()
                .verifyWith(getSigningKey())
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }
    
    private Boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }
    
    public String generateToken(UserDetails userDetails, List<String> roles, List<String> directorates) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("roles", roles);
        claims.put("directorates", directorates);
        return createToken(claims, userDetails.getUsername());
    }
    
    private String createToken(Map<String, Object> claims, String subject) {
        return Jwts.builder()
                .claims(claims)
                .subject(subject)
                .issuedAt(new Date(System.currentTimeMillis()))
                .expiration(new Date(System.currentTimeMillis() + jwtExpiration * 1000L))
                .signWith(getSigningKey())
                .compact();
    }
    
    public Boolean validateToken(String token, UserDetails userDetails) {
        final String username = extractUsername(token);
        return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));
    }
    
    public List<String> extractRoles(String token) {
        Claims claims = extractAllClaims(token);
        return claims.get("roles", List.class);
    }
    
    public List<String> extractDirectorates(String token) {
        Claims claims = extractAllClaims(token);
        return claims.get("directorates", List.class);
    }
}
Service Classes
JwtUserDetailsService.java
java
package com.example.auth.service;

import com.example.auth.entity.User;
import com.example.auth.entity.UserRole;
import com.example.auth.repository.UserRepository;
import com.example.auth.repository.UserRoleRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class JwtUserDetailsService implements UserDetailsService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private UserRoleRepository userRoleRepository;
    
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User not found: " + username));
        
        List<UserRole> userRoles = userRoleRepository.findByEmpId(user.getEmpId());
        List<GrantedAuthority> authorities = userRoles.stream()
                .map(role -> new SimpleGrantedAuthority("ROLE_" + role.getRoleName()))
                .collect(Collectors.toList());
        
        return new org.springframework.security.core.userdetails.User(
                user.getUsername(), 
                user.getPassword(), 
                user.isEnabled(), 
                true, 
                true, 
                true, 
                authorities);
    }
    
    public List<String> getUserRoles(String username) {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User not found: " + username));
        
        return userRoleRepository.findByEmpId(user.getEmpId())
                .stream()
                .map(UserRole::getRoleName)
                .distinct()
                .collect(Collectors.toList());
    }
    
    public List<String> getUserDirectorates(String username) {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User not found: " + username));
        
        return userRoleRepository.findByEmpId(user.getEmpId())
                .stream()
                .map(UserRole::getDirectorate)
                .distinct()
                .collect(Collectors.toList());
    }
}
Security Configuration
SecurityConfig.java
java
package com.example.auth.config;

import com.example.auth.service.JwtUserDetailsService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {
    
    @Autowired
    private JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint;
    
    @Autowired
    private JwtRequestFilter jwtRequestFilter;
    
    @Autowired
    private JwtUserDetailsService jwtUserDetailsService;
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(jwtUserDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }
    
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf(csrf -> csrf.disable())
                .authorizeHttpRequests(authz -> authz
                        .requestMatchers("/api/auth/**").permitAll()
                        .requestMatchers("/api/td/**").hasRole("TD")
                        .requestMatchers("/api/gd/**").hasRole("GD")
                        .anyRequest().authenticated()
                )
                .exceptionHandling(ex -> ex.authenticationEntryPoint(jwtAuthenticationEntryPoint))
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));
        
        http.addFilterBefore(jwtRequestFilter, UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
}
JwtAuthenticationEntryPoint.java
java
package com.example.auth.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@Component
public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {
    
    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response,
                         AuthenticationException authException) throws IOException {
        
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        
        final Map<String, Object> body = new HashMap<>();
        body.put("status", HttpServletResponse.SC_UNAUTHORIZED);
        body.put("error", "Unauthorized");
        body.put("message", authException.getMessage());
        body.put("path", request.getServletPath());
        
        final ObjectMapper mapper = new ObjectMapper();
        mapper.writeValue(response.getOutputStream(), body);
    }
}
JwtRequestFilter.java
java
package com.example.auth.config;

import com.example.auth.service.JwtUserDetailsService;
import com.example.auth.service.JwtUtil;
import io.jsonwebtoken.ExpiredJwtException;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
public class JwtRequestFilter extends OncePerRequestFilter {
    
    @Autowired
    private JwtUserDetailsService jwtUserDetailsService;
    
    @Autowired
    private JwtUtil jwtUtil;
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, 
                                    FilterChain chain) throws ServletException, IOException {
        
        final String requestTokenHeader = request.getHeader("Authorization");
        
        String username = null;
        String jwtToken = null;
        
        if (requestTokenHeader != null && requestTokenHeader.startsWith("Bearer ")) {
            jwtToken = requestTokenHeader.substring(7);
            try {
                username = jwtUtil.extractUsername(jwtToken);
            } catch (IllegalArgumentException e) {
                System.out.println("Unable to get JWT Token");
            } catch (ExpiredJwtException e) {
                System.out.println("JWT Token has expired");
            }
        }
        
        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            UserDetails userDetails = this.jwtUserDetailsService.loadUserByUsername(username);
            
            if (jwtUtil.validateToken(jwtToken, userDetails)) {
                UsernamePasswordAuthenticationToken authToken = 
                        new UsernamePasswordAuthenticationToken(
                                userDetails, null, userDetails.getAuthorities());
                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authToken);
            }
        }
        chain.doFilter(request, response);
    }
}
DTOs
JwtRequest.java
java
package com.example.auth.dto;

public class JwtRequest {
    private String username;
    private String password;
    
    public JwtRequest() {}
    
    public JwtRequest(String username, String password) {
        this.username = username;
        this.password = password;
    }
    
    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }
    
    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }
}
JwtResponse.java
java
package com.example.auth.dto;

import java.util.List;

public class JwtResponse {
    private String token;
    private String type = "Bearer";
    private String username;
    private List<String> roles;
    private List<String> directorates;
    
    public JwtResponse(String token, String username, List<String> roles, List<String> directorates) {
        this.token = token;
        this.username = username;
        this.roles = roles;
        this.directorates = directorates;
    }
    
    // Getters and Setters
    public String getToken() { return token; }
    public void setToken(String token) { this.token = token; }
    
    public String getType() { return type; }
    public void setType(String type) { this.type = type; }
    
    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }
    
    public List<String> getRoles() { return roles; }
    public void setRoles(List<String> roles) { this.roles = roles; }
    
    public List<String> getDirectorates() { return directorates; }
    public void setDirectorates(List<String> directorates) { this.directorates = directorates; }
}
Controllers
AuthController.java
java
package com.example.auth.controller;

import com.example.auth.dto.JwtRequest;
import com.example.auth.dto.JwtResponse;
import com.example.auth.service.JwtUserDetailsService;
import com.example.auth.service.JwtUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.DisabledException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/auth")
@CrossOrigin
public class AuthController {
    
    @Autowired
    private AuthenticationManager authenticationManager;
    
    @Autowired
    private JwtUtil jwtUtil;
    
    @Autowired
    private JwtUserDetailsService userDetailsService;
    
    @PostMapping("/login")
    public ResponseEntity<?> createAuthenticationToken(@RequestBody JwtRequest authenticationRequest) throws Exception {
        
        authenticate(authenticationRequest.getUsername(), authenticationRequest.getPassword());
        
        final UserDetails userDetails = userDetailsService
                .loadUserByUsername(authenticationRequest.getUsername());
        
        final List<String> roles = userDetailsService.getUserRoles(authenticationRequest.getUsername());
        final List<String> directorates = userDetailsService.getUserDirectorates(authenticationRequest.getUsername());
        
        final String token = jwtUtil.generateToken(userDetails, roles, directorates);
        
        return ResponseEntity.ok(new JwtResponse(token, userDetails.getUsername(), roles, directorates));
    }
    
    private void authenticate(String username, String password) throws Exception {
        try {
            authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(username, password));
        } catch (DisabledException e) {
            throw new Exception("USER_DISABLED", e);
        } catch (BadCredentialsException e) {
            throw new Exception("INVALID_CREDENTIALS", e);
        }
    }
}
UserController.java
java
package com.example.auth.controller;

import com.example.auth.service.JwtUtil;
import jakarta.servlet.http.HttpServletRequest;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api")
@CrossOrigin
public class UserController {
    
    @Autowired
    private JwtUtil jwtUtil;
    
    @GetMapping("/td/dashboard")
    @PreAuthorize("hasRole('TD')")
    public Map<String, Object> getTdDashboard(HttpServletRequest request) {
        String token = extractTokenFromRequest(request);
        List<String> directorates = jwtUtil.extractDirectorates(token);
        
        Map<String, Object> response = new HashMap<>();
        response.put("message", "Welcome to TD Dashboard");
        response.put("directorates", directorates);
        response.put("data", "TD specific data based on directorates");
        
        return response;
    }
    
    @GetMapping("/gd/dashboard")
    @PreAuthorize("hasRole('GD')")
    public Map<String, Object> getGdDashboard(HttpServletRequest request) {
        String token = extractTokenFromRequest(request);
        List<String> directorates = jwtUtil.extractDirectorates(token);
        
        Map<String, Object> response = new HashMap<>();
        response.put("message", "Welcome to GD Dashboard");
        response.put("directorates", directorates);
        response.put("data", "GD specific data based on directorates");
        
        return response;
    }
    
    @GetMapping("/user/profile")
    public Map<String, Object> getUserProfile(HttpServletRequest request) {
        String token = extractTokenFromRequest(request);
        String username = jwtUtil.extractUsername(token);
        List<String> roles = jwtUtil.extractRoles(token);
        List<String> directorates = jwtUtil.extractDirectorates(token);
        
        Map<String, Object> response = new HashMap<>();
        response.put("username", username);
        response.put("roles", roles);
        response.put("directorates", directorates);
        
        return response;
    }
    
    private String extractTokenFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
Application Properties
application.yml
text
spring:
  datasource:
    url: jdbc:h2:mem:testdb
    driver-class-name: org.h2.Driver
    username: sa
    password: password
  
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: create-drop
    show-sql: true
    
  h2:
    console:
      enabled: true
      path: /h2-console

jwt:
  secret: mySecretKey
  expiration: 86400

server:
  port: 8080

logging:
  level:
    com.example.auth: DEBUG
    org.springframework.security: DEBUG
Data Initialization
data.sql
sql
-- Insert roles
INSERT INTO role (role_no, role_name) VALUES (10, 'TD');
INSERT INTO role (role_no, role_name) VALUES (15, 'GD');

-- Insert users (password is 'password' encoded with BCrypt)
INSERT INTO users (username, password, enabled) VALUES ('user1', '$2a$10$slYQmyNdGzTn7ZLBXBChFOC9f6kFjAqPhccnP6DxlWXx2lPk1C3G6', true);
INSERT INTO users (username, password, enabled) VALUES ('user2', '$2a$10$slYQmyNdGzTn7ZLBXBChFOC9f6kFjAqPhccnP6DxlWXx2lPk1C3G6', true);

-- Insert user roles (assuming empId 1 for user1, empId 2 for user2)
INSERT INTO user_role (empid, role_no, role_name, directorate) VALUES (1, 10, 'TD', 'SDD');
INSERT INTO user_role (empid, role_no, role_name, directorate) VALUES (1, 10, 'TD', 'CND');
INSERT INTO user_role (empid, role_no, role_name, directorate) VALUES (2, 15, 'GD', 'SDD');
Main Application Class
AuthApplication.java
java
package com.example.auth;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class AuthApplication {
    public static void main(String[] args) {
        SpringApplication.run(AuthApplication.class, args);
    }
}
Usage Examples
Login Request
bash
POST /api/auth/login
Content-Type: application/json

{
    "username": "user1",
    "password": "password"
}
Response
json
{
    "token": "eyJhbGciOiJIUzI1NiJ9...",
    "type": "Bearer",
    "username": "user1",
    "roles": ["TD"],
    "directorates": ["SDD", "CND"]
}
Protected Resource Access
bash
GET /api/td/dashboard
Authorization: Bearer eyJhbGciOiJIUzI1NiJ9...
This implementation provides:

Multi-directorate support for users

Role-based access control with JWT

Spring Security integration

Flexible authentication system

Java 21 and Spring Boot 3.5.5 compatibility

{
    "token": "eyJhbGciOiJIUzI1NiJ9...",
    "type": "Bearer",
    "username": "user1",
    "roles": ["TD"],
    "directorates": ["SDD", "CND"]
}  here after aunthenticate i want need to ask user from which directorate u need to login like SDD or CND based on that we are restricting to the other

{ "token": "eyJhbGciOiJIUzI1NiJ9...", "type": "Bearer", "username": "user1", "roles": ["TD"], "directorates": ["SDD", "CND"] } here after aunthenticate i want need to ask user from which directorate u need to login like SDD or CND based on that we are restricting to the other
Enhanced JWT Authentication with Directorate Selection
Here's the updated implementation that adds directorate selection after initial authentication:

Updated DTOs
DirectorateSelectionRequest.java
java
package com.example.auth.dto;

public class DirectorateSelectionRequest {
    private String selectedDirectorate;
    
    public DirectorateSelectionRequest() {}
    
    public DirectorateSelectionRequest(String selectedDirectorate) {
        this.selectedDirectorate = selectedDirectorate;
    }
    
    public String getSelectedDirectorate() { return selectedDirectorate; }
    public void setSelectedDirectorate(String selectedDirectorate) { this.selectedDirectorate = selectedDirectorate; }
}
JwtResponse.java (Updated)
java
package com.example.auth.dto;

import java.util.List;

public class JwtResponse {
    private String token;
    private String type = "Bearer";
    private String username;
    private List<String> roles;
    private List<String> directorates;
    private String selectedDirectorate;
    private boolean requiresDirectorateSelection;
    
    // Constructor for initial login (multiple directorates)
    public JwtResponse(String username, List<String> roles, List<String> directorates) {
        this.username = username;
        this.roles = roles;
        this.directorates = directorates;
        this.requiresDirectorateSelection = directorates.size() > 1;
    }
    
    // Constructor for final token with selected directorate
    public JwtResponse(String token, String username, List<String> roles, String selectedDirectorate) {
        this.token = token;
        this.username = username;
        this.roles = roles;
        this.selectedDirectorate = selectedDirectorate;
        this.requiresDirectorateSelection = false;
    }
    
    // Getters and Setters
    public String getToken() { return token; }
    public void setToken(String token) { this.token = token; }
    
    public String getType() { return type; }
    public void setType(String type) { this.type = type; }
    
    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }
    
    public List<String> getRoles() { return roles; }
    public void setRoles(List<String> roles) { this.roles = roles; }
    
    public List<String> getDirectorates() { return directorates; }
    public void setDirectorates(List<String> directorates) { this.directorates = directorates; }
    
    public String getSelectedDirectorate() { return selectedDirectorate; }
    public void setSelectedDirectorate(String selectedDirectorate) { this.selectedDirectorate = selectedDirectorate; }
    
    public boolean isRequiresDirectorateSelection() { return requiresDirectorateSelection; }
    public void setRequiresDirectorateSelection(boolean requiresDirectorateSelection) { 
        this.requiresDirectorateSelection = requiresDirectorateSelection; 
    }
}
Updated JWT Utility
JwtUtil.java (Updated)
java
package com.example.auth.service;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;

@Component
public class JwtUtil {
    
    @Value("${jwt.secret:mySecretKey}")
    private String secret;
    
    @Value("${jwt.expiration:86400}")
    private int jwtExpiration;
    
    // Temporary token expiration (5 minutes for directorate selection)
    @Value("${jwt.temp-expiration:300}")
    private int tempJwtExpiration;
    
    private SecretKey getSigningKey() {
        return Keys.hmacShaKeyFor(secret.getBytes());
    }
    
    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }
    
    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }
    
    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }
    
    private Claims extractAllClaims(String token) {
        return Jwts.parser()
                .verifyWith(getSigningKey())
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }
    
    private Boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }
    
    // Generate temporary token for directorate selection
    public String generateTempToken(UserDetails userDetails, List<String> roles, List<String> directorates) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("roles", roles);
        claims.put("directorates", directorates);
        claims.put("temp", true);
        return createTempToken(claims, userDetails.getUsername());
    }
    
    // Generate final token with selected directorate
    public String generateToken(UserDetails userDetails, List<String> roles, String selectedDirectorate) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("roles", roles);
        claims.put("selectedDirectorate", selectedDirectorate);
        claims.put("temp", false);
        return createToken(claims, userDetails.getUsername());
    }
    
    private String createToken(Map<String, Object> claims, String subject) {
        return Jwts.builder()
                .claims(claims)
                .subject(subject)
                .issuedAt(new Date(System.currentTimeMillis()))
                .expiration(new Date(System.currentTimeMillis() + jwtExpiration * 1000L))
                .signWith(getSigningKey())
                .compact();
    }
    
    private String createTempToken(Map<String, Object> claims, String subject) {
        return Jwts.builder()
                .claims(claims)
                .subject(subject)
                .issuedAt(new Date(System.currentTimeMillis()))
                .expiration(new Date(System.currentTimeMillis() + tempJwtExpiration * 1000L))
                .signWith(getSigningKey())
                .compact();
    }
    
    public Boolean validateToken(String token, UserDetails userDetails) {
        final String username = extractUsername(token);
        return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));
    }
    
    public List<String> extractRoles(String token) {
        Claims claims = extractAllClaims(token);
        return claims.get("roles", List.class);
    }
    
    public List<String> extractDirectorates(String token) {
        Claims claims = extractAllClaims(token);
        return claims.get("directorates", List.class);
    }
    
    public String extractSelectedDirectorate(String token) {
        Claims claims = extractAllClaims(token);
        return claims.get("selectedDirectorate", String.class);
    }
    
    public boolean isTempToken(String token) {
        Claims claims = extractAllClaims(token);
        Boolean temp = claims.get("temp", Boolean.class);
        return temp != null && temp;
    }
}
Updated Service
DirectorateService.java (New)
java
package com.example.auth.service;

import com.example.auth.entity.UserRole;
import com.example.auth.repository.UserRepository;
import com.example.auth.repository.UserRoleRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class DirectorateService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private UserRoleRepository userRoleRepository;
    
    public boolean isValidDirectorateForUser(String username, String directorate) {
        return userRepository.findByUsername(username)
                .map(user -> userRoleRepository.findByEmpId(user.getEmpId())
                        .stream()
                        .anyMatch(role -> role.getDirectorate().equals(directorate)))
                .orElse(false);
    }
    
    public List<String> getUserDirectorates(String username) {
        return userRepository.findByUsername(username)
                .map(user -> userRoleRepository.findByEmpId(user.getEmpId())
                        .stream()
                        .map(UserRole::getDirectorate)
                        .distinct()
                        .collect(Collectors.toList()))
                .orElse(List.of());
    }
}
Updated Controllers
AuthController.java (Updated)
java
package com.example.auth.controller;

import com.example.auth.dto.DirectorateSelectionRequest;
import com.example.auth.dto.JwtRequest;
import com.example.auth.dto.JwtResponse;
import com.example.auth.service.DirectorateService;
import com.example.auth.service.JwtUserDetailsService;
import com.example.auth.service.JwtUtil;
import jakarta.servlet.http.HttpServletRequest;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.DisabledException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/auth")
@CrossOrigin
public class AuthController {
    
    @Autowired
    private AuthenticationManager authenticationManager;
    
    @Autowired
    private JwtUtil jwtUtil;
    
    @Autowired
    private JwtUserDetailsService userDetailsService;
    
    @Autowired
    private DirectorateService directorateService;
    
    @PostMapping("/login")
    public ResponseEntity<?> createAuthenticationToken(@RequestBody JwtRequest authenticationRequest) throws Exception {
        
        authenticate(authenticationRequest.getUsername(), authenticationRequest.getPassword());
        
        final UserDetails userDetails = userDetailsService
                .loadUserByUsername(authenticationRequest.getUsername());
        
        final List<String> roles = userDetailsService.getUserRoles(authenticationRequest.getUsername());
        final List<String> directorates = userDetailsService.getUserDirectorates(authenticationRequest.getUsername());
        
        // If user has multiple directorates, return response asking for directorate selection
        if (directorates.size() > 1) {
            final String tempToken = jwtUtil.generateTempToken(userDetails, roles, directorates);
            
            Map<String, Object> response = new HashMap<>();
            response.put("tempToken", tempToken);
            response.put("username", userDetails.getUsername());
            response.put("roles", roles);
            response.put("directorates", directorates);
            response.put("requiresDirectorateSelection", true);
            response.put("message", "Please select a directorate to continue");
            
            return ResponseEntity.ok(response);
        } else {
            // Single directorate - generate final token directly
            String selectedDirectorate = directorates.get(0);
            final String token = jwtUtil.generateToken(userDetails, roles, selectedDirectorate);
            
            return ResponseEntity.ok(new JwtResponse(token, userDetails.getUsername(), roles, selectedDirectorate));
        }
    }
    
    @PostMapping("/select-directorate")
    public ResponseEntity<?> selectDirectorate(@RequestBody DirectorateSelectionRequest request, 
                                              HttpServletRequest httpRequest) throws Exception {
        
        String tempToken = extractTokenFromRequest(httpRequest);
        if (tempToken == null || !jwtUtil.isTempToken(tempToken)) {
            return ResponseEntity.badRequest().body("Invalid or missing temporary token");
        }
        
        String username = jwtUtil.extractUsername(tempToken);
        List<String> availableDirectorates = jwtUtil.extractDirectorates(tempToken);
        List<String> roles = jwtUtil.extractRoles(tempToken);
        
        // Validate selected directorate
        if (!availableDirectorates.contains(request.getSelectedDirectorate())) {
            return ResponseEntity.badRequest().body("Invalid directorate selection");
        }
        
        // Verify user has access to selected directorate
        if (!directorateService.isValidDirectorateForUser(username, request.getSelectedDirectorate())) {
            return ResponseEntity.badRequest().body("User does not have access to selected directorate");
        }
        
        final UserDetails userDetails = userDetailsService.loadUserByUsername(username);
        final String finalToken = jwtUtil.generateToken(userDetails, roles, request.getSelectedDirectorate());
        
        return ResponseEntity.ok(new JwtResponse(finalToken, username, roles, request.getSelectedDirectorate()));
    }
    
    @GetMapping("/user-directorates")
    public ResponseEntity<?> getUserDirectorates(HttpServletRequest request) {
        String tempToken = extractTokenFromRequest(request);
        if (tempToken == null || !jwtUtil.isTempToken(tempToken)) {
            return ResponseEntity.badRequest().body("Invalid or missing temporary token");
        }
        
        String username = jwtUtil.extractUsername(tempToken);
        List<String> directorates = directorateService.getUserDirectorates(username);
        
        Map<String, Object> response = new HashMap<>();
        response.put("username", username);
        response.put("directorates", directorates);
        
        return ResponseEntity.ok(response);
    }
    
    private void authenticate(String username, String password) throws Exception {
        try {
            authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(username, password));
        } catch (DisabledException e) {
            throw new Exception("USER_DISABLED", e);
        } catch (BadCredentialsException e) {
            throw new Exception("INVALID_CREDENTIALS", e);
        }
    }
    
    private String extractTokenFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
UserController.java (Updated)
java
package com.example.auth.controller;

import com.example.auth.service.JwtUtil;
import jakarta.servlet.http.HttpServletRequest;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api")
@CrossOrigin
public class UserController {
    
    @Autowired
    private JwtUtil jwtUtil;
    
    @GetMapping("/td/dashboard")
    @PreAuthorize("hasRole('TD')")
    public ResponseEntity<?> getTdDashboard(HttpServletRequest request) {
        String token = extractTokenFromRequest(request);
        
        if (jwtUtil.isTempToken(token)) {
            return ResponseEntity.badRequest().body("Please complete directorate selection first");
        }
        
        String selectedDirectorate = jwtUtil.extractSelectedDirectorate(token);
        String username = jwtUtil.extractUsername(token);
        
        Map<String, Object> response = new HashMap<>();
        response.put("message", "Welcome to TD Dashboard");
        response.put("username", username);
        response.put("selectedDirectorate", selectedDirectorate);
        response.put("data", getTdDataForDirectorate(selectedDirectorate));
        
        return ResponseEntity.ok(response);
    }
    
    @GetMapping("/gd/dashboard")
    @PreAuthorize("hasRole('GD')")
    public ResponseEntity<?> getGdDashboard(HttpServletRequest request) {
        String token = extractTokenFromRequest(request);
        
        if (jwtUtil.isTempToken(token)) {
            return ResponseEntity.badRequest().body("Please complete directorate selection first");
        }
        
        String selectedDirectorate = jwtUtil.extractSelectedDirectorate(token);
        String username = jwtUtil.extractUsername(token);
        
        Map<String, Object> response = new HashMap<>();
        response.put("message", "Welcome to GD Dashboard");
        response.put("username", username);
        response.put("selectedDirectorate", selectedDirectorate);
        response.put("data", getGdDataForDirectorate(selectedDirectorate));
        
        return ResponseEntity.ok(response);
    }
    
    @GetMapping("/user/profile")
    public ResponseEntity<?> getUserProfile(HttpServletRequest request) {
        String token = extractTokenFromRequest(request);
        
        if (jwtUtil.isTempToken(token)) {
            return ResponseEntity.badRequest().body("Please complete directorate selection first");
        }
        
        String username = jwtUtil.extractUsername(token);
        List<String> roles = jwtUtil.extractRoles(token);
        String selectedDirectorate = jwtUtil.extractSelectedDirectorate(token);
        
        Map<String, Object> response = new HashMap<>();
        response.put("username", username);
        response.put("roles", roles);
        response.put("selectedDirectorate", selectedDirectorate);
        
        return ResponseEntity.ok(response);
    }
    
    private String extractTokenFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
    
    private Map<String, Object> getTdDataForDirectorate(String directorate) {
        Map<String, Object> data = new HashMap<>();
        data.put("reports", "TD reports for " + directorate);
        data.put("projects", "TD projects in " + directorate);
        data.put("teams", "TD teams under " + directorate);
        return data;
    }
    
    private Map<String, Object> getGdDataForDirectorate(String directorate) {
        Map<String, Object> data = new HashMap<>();
        data.put("overview", "GD overview for " + directorate);
        data.put("statistics", "GD statistics in " + directorate);
        data.put("operations", "GD operations under " + directorate);
        return data;
    }
}
Updated Security Filter
JwtRequestFilter.java (Updated)
java
package com.example.auth.config;

import com.example.auth.service.JwtUserDetailsService;
import com.example.auth.service.JwtUtil;
import io.jsonwebtoken.ExpiredJwtException;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;

@Component
public class JwtRequestFilter extends OncePerRequestFilter {
    
    @Autowired
    private JwtUserDetailsService jwtUserDetailsService;
    
    @Autowired
    private JwtUtil jwtUtil;
    
    // Endpoints that allow temporary tokens
    private static final List<String> TEMP_TOKEN_ALLOWED_ENDPOINTS = Arrays.asList(
        "/api/auth/select-directorate",
        "/api/auth/user-directorates"
    );
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, 
                                    FilterChain chain) throws ServletException, IOException {
        
        final String requestTokenHeader = request.getHeader("Authorization");
        final String requestURI = request.getRequestURI();
        
        String username = null;
        String jwtToken = null;
        
        if (requestTokenHeader != null && requestTokenHeader.startsWith("Bearer ")) {
            jwtToken = requestTokenHeader.substring(7);
            try {
                username = jwtUtil.extractUsername(jwtToken);
                
                // Check if it's a temporary token being used on non-allowed endpoints
                if (jwtUtil.isTempToken(jwtToken) && !isTempTokenAllowedEndpoint(requestURI)) {
                    response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
                    response.getWriter().write("{\"error\":\"Please complete directorate selection first\"}");
                    return;
                }
                
            } catch (IllegalArgumentException e) {
                System.out.println("Unable to get JWT Token");
            } catch (ExpiredJwtException e) {
                System.out.println("JWT Token has expired");
            }
        }
        
        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            UserDetails userDetails = this.jwtUserDetailsService.loadUserByUsername(username);
            
            if (jwtUtil.validateToken(jwtToken, userDetails)) {
                UsernamePasswordAuthenticationToken authToken = 
                        new UsernamePasswordAuthenticationToken(
                                userDetails, null, userDetails.getAuthorities());
                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authToken);
            }
        }
        chain.doFilter(request, response);
    }
    
    private boolean isTempTokenAllowedEndpoint(String requestURI) {
        return TEMP_TOKEN_ALLOWED_ENDPOINTS.stream()
                .anyMatch(requestURI::startsWith);
    }
}
Updated Application Properties
application.yml (Updated)
text
spring:
  datasource:
    url: jdbc:h2:mem:testdb
    driver-class-name: org.h2.Driver
    username: sa
    password: password
  
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: create-drop
    show-sql: true
    
  h2:
    console:
      enabled: true
      path: /h2-console

jwt:
  secret: mySecretKey
  expiration: 86400
  temp-expiration: 300  # 5 minutes for directorate selection

server:
  port: 8080

logging:
  level:
    com.example.auth: DEBUG
    org.springframework.security: DEBUG
Usage Flow Examples
1. Initial Login (Multiple Directorates)
Request:

bash
POST /api/auth/login
Content-Type: application/json

{
    "username": "user1",
    "password": "password"
}
Response:

json
{
    "tempToken": "eyJhbGciOiJIUzI1NiJ9...",
    "username": "user1",
    "roles": ["TD"],
    "directorates": ["SDD", "CND"],
    "requiresDirectorateSelection": true,
    "message": "Please select a directorate to continue"
}
2. Directorate Selection
Request:

bash
POST /api/auth/select-directorate
Authorization: Bearer eyJhbGciOiJIUzI1NiJ9...
Content-Type: application/json

{
    "selectedDirectorate": "SDD"
}
Response:

json
{
    "token": "eyJhbGciOiJIUzI1NiJ9...",
    "type": "Bearer",
    "username": "user1",
    "roles": ["TD"],
    "selectedDirectorate": "SDD"
}
3. Access Protected Resources
Request:

bash
GET /api/td/dashboard
Authorization: Bearer eyJhbGciOiJIUzI1NiJ9...
Response:

json
{
    "message": "Welcome to TD Dashboard",
    "username": "user1",
    "selectedDirectorate": "SDD",
    "data": {
        "reports": "TD reports for SDD",
        "projects": "TD projects in SDD",
        "teams": "TD teams under SDD"
    }
}
Key Features
Two-step authentication: Initial login + directorate selection

Temporary tokens: 5-minute expiry for directorate selection

Directorate-specific access: Users can only access data from their selected directorate

Security restrictions: Temporary tokens can't access protected resources

Flexible flow: Single directorate users skip selection step

Validation: Ensures users can only select directorates they have access to

This implementation provides secure, directorate-specific access control while maintaining a smooth user experience.

if no ultiple directorates are there directly need to login

if no ultiple directorates are there directly need to login
You're absolutely right! The current implementation already handles this scenario. Let me show you exactly how it works and provide a cleaner version:

Current Flow Logic
In the AuthController.java, the login method already checks for multiple directorates:

java
@PostMapping("/login")
public ResponseEntity<?> createAuthenticationToken(@RequestBody JwtRequest authenticationRequest) throws Exception {
    
    authenticate(authenticationRequest.getUsername(), authenticationRequest.getPassword());
    
    final UserDetails userDetails = userDetailsService
            .loadUserByUsername(authenticationRequest.getUsername());
    
    final List<String> roles = userDetailsService.getUserRoles(authenticationRequest.getUsername());
    final List<String> directorates = userDetailsService.getUserDirectorates(authenticationRequest.getUsername());
    
    // ✅ If user has multiple directorates, ask for selection
    if (directorates.size() > 1) {
        final String tempToken = jwtUtil.generateTempToken(userDetails, roles, directorates);
        
        Map<String, Object> response = new HashMap<>();
        response.put("tempToken", tempToken);
        response.put("username", userDetails.getUsername());
        response.put("roles", roles);
        response.put("directorates", directorates);
        response.put("requiresDirectorateSelection", true);
        response.put("message", "Please select a directorate to continue");
        
        return ResponseEntity.ok(response);
    } else {
        // ✅ Single directorate - generate final token directly (NO SELECTION NEEDED)
        String selectedDirectorate = directorates.get(0);
        final String token = jwtUtil.generateToken(userDetails, roles, selectedDirectorate);
        
        return ResponseEntity.ok(new JwtResponse(token, userDetails.getUsername(), roles, selectedDirectorate));
    }
}
Example Scenarios
Scenario 1: User with Single Directorate (user2 - GD with only SDD)
Request:

bash
POST /api/auth/login
Content-Type: application/json

{
    "username": "user2",
    "password": "password"
}
Response (Direct Login - No Selection Required):

json
{
    "token": "eyJhbGciOiJIUzI1NiJ9...",
    "type": "Bearer",
    "username": "user2",
    "roles": ["GD"],
    "selectedDirectorate": "SDD",
    "requiresDirectorateSelection": false
}
Scenario 2: User with Multiple Directorates (user1 - TD with SDD and CND)
Request:

bash
POST /api/auth/login
Content-Type: application/json

{
    "username": "user1", 
    "password": "password"
}
Response (Requires Selection):

json
{
    "tempToken": "eyJhbGciOiJIUzI1NiJ9...",
    "username": "user1",
    "roles": ["TD"],
    "directorates": ["SDD", "CND"],
    "requiresDirectorateSelection": true,
    "message": "Please select a directorate to continue"
}
Updated JwtResponse.java (Cleaner)
Here's a cleaner version of the response DTO:

java
package com.example.auth.dto;

import java.util.List;

public class JwtResponse {
    private String token;
    private String tempToken;
    private String type = "Bearer";
    private String username;
    private List<String> roles;
    private List<String> directorates;
    private String selectedDirectorate;
    private boolean requiresDirectorateSelection;
    private String message;
    
    // Constructor for single directorate (direct login)
    public JwtResponse(String token, String username, List<String> roles, String selectedDirectorate) {
        this.token = token;
        this.username = username;
        this.roles = roles;
        this.selectedDirectorate = selectedDirectorate;
        this.requiresDirectorateSelection = false;
    }
    
    // Constructor for multiple directorates (requires selection)
    public JwtResponse(String tempToken, String username, List<String> roles, List<String> directorates, String message) {
        this.tempToken = tempToken;
        this.username = username;
        this.roles = roles;
        this.directorates = directorates;
        this.requiresDirectorateSelection = true;
        this.message = message;
    }
    
    // Getters and Setters
    public String getToken() { return token; }
    public void setToken(String token) { this.token = token; }
    
    public String getTempToken() { return tempToken; }
    public void setTempToken(String tempToken) { this.tempToken = tempToken; }
    
    public String getType() { return type; }
    public void setType(String type) { this.type = type; }
    
    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }
    
    public List<String> getRoles() { return roles; }
    public void setRoles(List<String> roles) { this.roles = roles; }
    
    public List<String> getDirectorates() { return directorates; }
    public void setDirectorates(List<String> directorates) { this.directorates = directorates; }
    
    public String getSelectedDirectorate() { return selectedDirectorate; }
    public void setSelectedDirectorate(String selectedDirectorate) { this.selectedDirectorate = selectedDirectorate; }
    
    public boolean isRequiresDirectorateSelection() { return requiresDirectorateSelection; }
    public void setRequiresDirectorateSelection(boolean requiresDirectorateSelection) { 
        this.requiresDirectorateSelection = requiresDirectorateSelection; 
    }
    
    public String getMessage() { return message; }
    public void setMessage(String message) { this.message = message; }
}
Updated AuthController.java (Cleaner)
java
@PostMapping("/login")
public ResponseEntity<?> createAuthenticationToken(@RequestBody JwtRequest authenticationRequest) throws Exception {
    
    authenticate(authenticationRequest.getUsername(), authenticationRequest.getPassword());
    
    final UserDetails userDetails = userDetailsService
            .loadUserByUsername(authenticationRequest.getUsername());
    
    final List<String> roles = userDetailsService.getUserRoles(authenticationRequest.getUsername());
    final List<String> directorates = userDetailsService.getUserDirectorates(authenticationRequest.getUsername());
    
    if (directorates.size() > 1) {
        // Multiple directorates - require selection
        final String tempToken = jwtUtil.generateTempToken(userDetails, roles, directorates);
        return ResponseEntity.ok(new JwtResponse(tempToken, userDetails.getUsername(), roles, directorates, 
                "Please select a directorate to continue"));
    } else {
        // Single directorate - direct login
        String selectedDirectorate = directorates.get(0);
        final String token = jwtUtil.generateToken(userDetails, roles, selectedDirectorate);
        return ResponseEntity.ok(new JwtResponse(token, userDetails.getUsername(), roles, selectedDirectorate));
    }
}
Frontend Logic Example
javascript
// Login function
async function login(username, password) {
    const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username, password })
    });
    
    const data = await response.json();
    
    if (data.requiresDirectorateSelection) {
        // Show directorate selection UI
        showDirectorateSelection(data.directorates, data.tempToken);
    } else {
        // Direct login - store token and redirect to dashboard
        localStorage.setItem('authToken', data.token);
        localStorage.setItem('selectedDirectorate', data.selectedDirectorate);
        redirectToDashboard(data.roles[0]);
    }
}

function showDirectorateSelection(directorates, tempToken) {
    // Display UI with directorate options
    // When user selects, call selectDirectorate()
}

async function selectDirectorate(selectedDirectorate, tempToken) {
    const response = await fetch('/api/auth/select-directorate', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${tempToken}`
        },
        body: JSON.stringify({ selectedDirectorate })
    });
    
    const data = await response.json();
    localStorage.setItem('authToken', data.token);
    localStorage.setItem('selectedDirectorate', data.selectedDirectorate);
    redirectToDashboard(data.roles[0]);
}
The system automatically:

Single directorate users: Get direct access with full JWT token

Multiple directorate users: Must select directorate first

No extra steps for users with only one directorate access

give entire for Mysql and oracle 21C

give entire for Mysql and oracle 21C
Complete Spring Boot 3.5.5 JWT Authentication with MySQL and Oracle 21c
Project Dependencies (pom.xml)
xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.5.5</version>
        <relativePath/>
    </parent>
    
    <groupId>com.example</groupId>
    <artifactId>jwt-auth-db</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <packaging>jar</packaging>
    
    <properties>
        <java.version>21</java.version>
    </properties>
    
    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        
        <!-- JWT Dependencies -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
            <version>0.12.3</version>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
            <version>0.12.3</version>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
            <version>0.12.3</version>
            <scope>runtime</scope>
        </dependency>
        
        <!-- Database Drivers -->
        <!-- MySQL Connector -->
        <dependency>
            <groupId>com.mysql</groupId>
            <artifactId>mysql-connector-j</artifactId>
            <scope>runtime</scope>
        </dependency>
        
        <!-- Oracle JDBC Driver -->
        <dependency>
            <groupId>com.oracle.database.jdbc</groupId>
            <artifactId>ojdbc11</artifactId>
            <scope>runtime</scope>
        </dependency>
        
        <!-- Connection Pooling -->
        <dependency>
            <groupId>com.zaxxer</groupId>
            <artifactId>HikariCP</artifactId>
        </dependency>
        
        <!-- Development Tools -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-devtools</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        
        <!-- Testing -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
Configuration Files
application.yml
text
server:
  port: 8080

logging:
  level:
    com.example.auth: DEBUG
    org.springframework.security: DEBUG
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql.BasicBinder: TRACE

jwt:
  secret: MySecretKeyForJWTTokenGenerationAndValidation2025
  expiration: 86400  # 24 hours in seconds
  temp-expiration: 300  # 5 minutes for directorate selection

spring:
  profiles:
    active: mysql  # Change to 'oracle' for Oracle database

---
# MySQL Configuration
spring:
  config:
    activate:
      on-profile: mysql
  datasource:
    url: jdbc:mysql://localhost:3306/jwt_auth_db?useSSL=false&serverTimezone=UTC&allowPublicKeyRetrieval=true
    username: root
    password: password
    driver-class-name: com.mysql.cj.jdbc.Driver
    hikari:
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
      maximum-pool-size: 10
      minimum-idle: 5
  
  jpa:
    database-platform: org.hibernate.dialect.MySQLDialect
    hibernate:
      ddl-auto: update
      naming:
        physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
    show-sql: true
    properties:
      hibernate:
        format_sql: true
        jdbc:
          batch_size: 20

---
# Oracle Configuration
spring:
  config:
    activate:
      on-profile: oracle
  datasource:
    url: jdbc:oracle:thin:@localhost:1521:XE
    username: jwt_user
    password: password
    driver-class-name: oracle.jdbc.OracleDriver
    hikari:
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
      maximum-pool-size: 10
      minimum-idle: 5
  
  jpa:
    database-platform: org.hibernate.dialect.Oracle21cDialect
    hibernate:
      ddl-auto: update
      naming:
        physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
    show-sql: true
    properties:
      hibernate:
        format_sql: true
        jdbc:
          batch_size: 20
Entity Classes
Role.java
java
package com.example.auth.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;

@Entity
@Table(name = "roles")
public class Role {
    @Id
    @Column(name = "role_no")
    @NotNull(message = "Role number is required")
    private Integer roleNo;
    
    @Column(name = "role_name", nullable = false, length = 50)
    @NotBlank(message = "Role name is required")
    private String roleName;
    
    // Constructors
    public Role() {}
    
    public Role(Integer roleNo, String roleName) {
        this.roleNo = roleNo;
        this.roleName = roleName;
    }
    
    // Getters and Setters
    public Integer getRoleNo() { return roleNo; }
    public void setRoleNo(Integer roleNo) { this.roleNo = roleNo; }
    
    public String getRoleName() { return roleName; }
    public void setRoleName(String roleName) { this.roleName = roleName; }
    
    @Override
    public String toString() {
        return "Role{roleNo=" + roleNo + ", roleName='" + roleName + "'}";
    }
}
User.java
java
package com.example.auth.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;

@Entity
@Table(name = "users", 
       uniqueConstraints = {
           @UniqueConstraint(columnNames = "username"),
           @UniqueConstraint(columnNames = "email")
       })
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "emp_id")
    private Long empId;
    
    @Column(name = "username", unique = true, nullable = false, length = 50)
    @NotBlank(message = "Username is required")
    @Size(max = 50, message = "Username must not exceed 50 characters")
    private String username;
    
    @Column(name = "email", unique = true, nullable = false, length = 100)
    @NotBlank(message = "Email is required")
    @Email(message = "Email should be valid")
    @Size(max = 100, message = "Email must not exceed 100 characters")
    private String email;
    
    @Column(name = "password", nullable = false)
    @NotBlank(message = "Password is required")
    @Size(min = 6, message = "Password must be at least 6 characters")
    private String password;
    
    @Column(name = "first_name", length = 50)
    private String firstName;
    
    @Column(name = "last_name", length = 50)
    private String lastName;
    
    @Column(name = "enabled", nullable = false)
    private Boolean enabled = true;
    
    @Column(name = "account_non_expired", nullable = false)
    private Boolean accountNonExpired = true;
    
    @Column(name = "account_non_locked", nullable = false)
    private Boolean accountNonLocked = true;
    
    @Column(name = "credentials_non_expired", nullable = false)
    private Boolean credentialsNonExpired = true;
    
    @CreationTimestamp
    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;
    
    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    // Constructors
    public User() {}
    
    public User(String username, String email, String password) {
        this.username = username;
        this.email = email;
        this.password = password;
    }
    
    // Getters and Setters
    public Long getEmpId() { return empId; }
    public void setEmpId(Long empId) { this.empId = empId; }
    
    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }
    
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    
    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }
    
    public String getFirstName() { return firstName; }
    public void setFirstName(String firstName) { this.firstName = firstName; }
    
    public String getLastName() { return lastName; }
    public void setLastName(String lastName) { this.lastName = lastName; }
    
    public Boolean getEnabled() { return enabled; }
    public void setEnabled(Boolean enabled) { this.enabled = enabled; }
    
    public Boolean getAccountNonExpired() { return accountNonExpired; }
    public void setAccountNonExpired(Boolean accountNonExpired) { this.accountNonExpired = accountNonExpired; }
    
    public Boolean getAccountNonLocked() { return accountNonLocked; }
    public void setAccountNonLocked(Boolean accountNonLocked) { this.accountNonLocked = accountNonLocked; }
    
    public Boolean getCredentialsNonExpired() { return credentialsNonExpired; }
    public void setCredentialsNonExpired(Boolean credentialsNonExpired) { this.credentialsNonExpired = credentialsNonExpired; }
    
    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
    
    public LocalDateTime getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }
}
UserRole.java
java
package com.example.auth.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;

@Entity
@Table(name = "user_roles")
@IdClass(UserRoleId.class)
public class UserRole {
    @Id
    @Column(name = "emp_id")
    @NotNull(message = "Employee ID is required")
    private Long empId;
    
    @Id
    @Column(name = "role_no")
    @NotNull(message = "Role number is required")
    private Integer roleNo;
    
    @Id
    @Column(name = "directorate", length = 10)
    @NotBlank(message = "Directorate is required")
    private String directorate;
    
    @Column(name = "role_name", nullable = false, length = 50)
    @NotBlank(message = "Role name is required")
    private String roleName;
    
    @Column(name = "is_active", nullable = false)
    private Boolean isActive = true;
    
    // Constructors
    public UserRole() {}
    
    public UserRole(Long empId, Integer roleNo, String roleName, String directorate) {
        this.empId = empId;
        this.roleNo = roleNo;
        this.roleName = roleName;
        this.directorate = directorate;
    }
    
    // Getters and Setters
    public Long getEmpId() { return empId; }
    public void setEmpId(Long empId) { this.empId = empId; }
    
    public Integer getRoleNo() { return roleNo; }
    public void setRoleNo(Integer roleNo) { this.roleNo = roleNo; }
    
    public String getRoleName() { return roleName; }
    public void setRoleName(String roleName) { this.roleName = roleName; }
    
    public String getDirectorate() { return directorate; }
    public void setDirectorate(String directorate) { this.directorate = directorate; }
    
    public Boolean getIsActive() { return isActive; }
    public void setIsActive(Boolean isActive) { this.isActive = isActive; }
    
    @Override
    public String toString() {
        return "UserRole{empId=" + empId + ", roleNo=" + roleNo + 
               ", roleName='" + roleName + "', directorate='" + directorate + "'}";
    }
}
UserRoleId.java
java
package com.example.auth.entity;

import java.io.Serializable;
import java.util.Objects;

public class UserRoleId implements Serializable {
    private Long empId;
    private Integer roleNo;
    private String directorate;
    
    public UserRoleId() {}
    
    public UserRoleId(Long empId, Integer roleNo, String directorate) {
        this.empId = empId;
        this.roleNo = roleNo;
        this.directorate = directorate;
    }
    
    // Getters and Setters
    public Long getEmpId() { return empId; }
    public void setEmpId(Long empId) { this.empId = empId; }
    
    public Integer getRoleNo() { return roleNo; }
    public void setRoleNo(Integer roleNo) { this.roleNo = roleNo; }
    
    public String getDirectorate() { return directorate; }
    public void setDirectorate(String directorate) { this.directorate = directorate; }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        UserRoleId that = (UserRoleId) o;
        return Objects.equals(empId, that.empId) && 
               Objects.equals(roleNo, that.roleNo) && 
               Objects.equals(directorate, that.directorate);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(empId, roleNo, directorate);
    }
}
Repository Interfaces
UserRepository.java
java
package com.example.auth.repository;

import com.example.auth.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    Optional<User> findByUsername(String username);
    
    Optional<User> findByEmail(String email);
    
    Boolean existsByUsername(String username);
    
    Boolean existsByEmail(String email);
    
    @Query("SELECT u FROM User u WHERE u.username = :username AND u.enabled = true")
    Optional<User> findActiveUserByUsername(@Param("username") String username);
    
    @Query("SELECT u FROM User u WHERE u.email = :email AND u.enabled = true")
    Optional<User> findActiveUserByEmail(@Param("email") String email);
}
UserRoleRepository.java
java
package com.example.auth.repository;

import com.example.auth.entity.UserRole;
import com.example.auth.entity.UserRoleId;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface UserRoleRepository extends JpaRepository<UserRole, UserRoleId> {
    
    List<UserRole> findByEmpId(Long empId);
    
    List<UserRole> findByEmpIdAndIsActive(Long empId, Boolean isActive);
    
    @Query("SELECT ur FROM UserRole ur WHERE ur.empId = :empId AND ur.isActive = true")
    List<UserRole> findActiveRolesByEmpId(@Param("empId") Long empId);
    
    @Query("SELECT DISTINCT ur.directorate FROM UserRole ur WHERE ur.empId = :empId AND ur.isActive = true")
    List<String> findDirectoratesByEmpId(@Param("empId") Long empId);
    
    @Query("SELECT DISTINCT ur.roleName FROM UserRole ur WHERE ur.empId = :empId AND ur.isActive = true")
    List<String> findRoleNamesByEmpId(@Param("empId") Long empId);
    
    @Query("SELECT COUNT(ur) > 0 FROM UserRole ur WHERE ur.empId = :empId AND ur.directorate = :directorate AND ur.isActive = true")
    Boolean existsByEmpIdAndDirectorateAndIsActive(@Param("empId") Long empId, @Param("directorate") String directorate);
}
RoleRepository.java
java
package com.example.auth.repository;

import com.example.auth.entity.Role;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface RoleRepository extends JpaRepository<Role, Integer> {
    
    Optional<Role> findByRoleName(String roleName);
    
    Boolean existsByRoleName(String roleName);
}
Service Classes
JwtUtil.java
java
package com.example.auth.service;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;

@Component
public class JwtUtil {
    
    private static final Logger logger = LoggerFactory.getLogger(JwtUtil.class);
    
    @Value("${jwt.secret}")
    private String secret;
    
    @Value("${jwt.expiration}")
    private int jwtExpiration;
    
    @Value("${jwt.temp-expiration}")
    private int tempJwtExpiration;
    
    private SecretKey getSigningKey() {
        return Keys.hmacShaKeyFor(secret.getBytes());
    }
    
    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }
    
    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }
    
    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }
    
    private Claims extractAllClaims(String token) {
        try {
            return Jwts.parser()
                    .verifyWith(getSigningKey())
                    .build()
                    .parseSignedClaims(token)
                    .getPayload();
        } catch (Exception e) {
            logger.error("Error parsing JWT token: {}", e.getMessage());
            throw e;
        }
    }
    
    private Boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }
    
    // Generate temporary token for directorate selection
    public String generateTempToken(UserDetails userDetails, List<String> roles, List<String> directorates) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("roles", roles);
        claims.put("directorates", directorates);
        claims.put("temp", true);
        claims.put("empId", getUserIdFromUserDetails(userDetails));
        
        logger.debug("Generating temp token for user: {}", userDetails.getUsername());
        return createTempToken(claims, userDetails.getUsername());
    }
    
    // Generate final token with selected directorate
    public String generateToken(UserDetails userDetails, List<String> roles, String selectedDirectorate) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("roles", roles);
        claims.put("selectedDirectorate", selectedDirectorate);
        claims.put("temp", false);
        claims.put("empId", getUserIdFromUserDetails(userDetails));
        
        logger.debug("Generating final token for user: {} with directorate: {}", 
                    userDetails.getUsername(), selectedDirectorate);
        return createToken(claims, userDetails.getUsername());
    }
    
    private String createToken(Map<String, Object> claims, String subject) {
        return Jwts.builder()
                .claims(claims)
                .subject(subject)
                .issuedAt(new Date(System.currentTimeMillis()))
                .expiration(new Date(System.currentTimeMillis() + jwtExpiration * 1000L))
                .signWith(getSigningKey())
                .compact();
    }
    
    private String createTempToken(Map<String, Object> claims, String subject) {
        return Jwts.builder()
                .claims(claims)
                .subject(subject)
                .issuedAt(new Date(System.currentTimeMillis()))
                .expiration(new Date(System.currentTimeMillis() + tempJwtExpiration * 1000L))
                .signWith(getSigningKey())
                .compact();
    }
    
    public Boolean validateToken(String token, UserDetails userDetails) {
        final String username = extractUsername(token);
        return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));
    }
    
    @SuppressWarnings("unchecked")
    public List<String> extractRoles(String token) {
        Claims claims = extractAllClaims(token);
        return (List<String>) claims.get("roles");
    }
    
    @SuppressWarnings("unchecked")
    public List<String> extractDirectorates(String token) {
        Claims claims = extractAllClaims(token);
        return (List<String>) claims.get("directorates");
    }
    
    public String extractSelectedDirectorate(String token) {
        Claims claims = extractAllClaims(token);
        return (String) claims.get("selectedDirectorate");
    }
    
    public Long extractEmpId(String token) {
        Claims claims = extractAllClaims(token);
        Object empId = claims.get("empId");
        if (empId instanceof Integer) {
            return ((Integer) empId).longValue();
        }
        return (Long) empId;
    }
    
    public boolean isTempToken(String token) {
        Claims claims = extractAllClaims(token);
        Boolean temp = (Boolean) claims.get("temp");
        return temp != null && temp;
    }
    
    private Long getUserIdFromUserDetails(UserDetails userDetails) {
        if (userDetails instanceof UserDetailsImpl) {
            return ((UserDetailsImpl) userDetails).getId();
        }
        return null;
    }
}
UserDetailsImpl.java
java
package com.example.auth.service;

import com.example.auth.entity.User;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

public class UserDetailsImpl implements UserDetails {
    
    private static final long serialVersionUID = 1L;
    
    private Long id;
    private String username;
    private String email;
    private String password;
    private Collection<? extends GrantedAuthority> authorities;
    private boolean enabled;
    private boolean accountNonExpired;
    private boolean accountNonLocked;
    private boolean credentialsNonExpired;
    
    public UserDetailsImpl(Long id, String username, String email, String password,
                          Collection<? extends GrantedAuthority> authorities,
                          boolean enabled, boolean accountNonExpired,
                          boolean accountNonLocked, boolean credentialsNonExpired) {
        this.id = id;
        this.username = username;
        this.email = email;
        this.password = password;
        this.authorities = authorities;
        this.enabled = enabled;
        this.accountNonExpired = accountNonExpired;
        this.accountNonLocked = accountNonLocked;
        this.credentialsNonExpired = credentialsNonExpired;
    }
    
    public static UserDetailsImpl build(User user, List<String> roles) {
        List<GrantedAuthority> authorities = roles.stream()
                .map(role -> new SimpleGrantedAuthority("ROLE_" + role))
                .collect(Collectors.toList());
        
        return new UserDetailsImpl(
                user.getEmpId(),
                user.getUsername(),
                user.getEmail(),
                user.getPassword(),
                authorities,
                user.getEnabled(),
                user.getAccountNonExpired(),
                user.getAccountNonLocked(),
                user.getCredentialsNonExpired());
    }
    
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return authorities;
    }
    
    public Long getId() {
        return id;
    }
    
    public String getEmail() {
        return email;
    }
    
    @Override
    public String getPassword() {
        return password;
    }
    
    @Override
    public String getUsername() {
        return username;
    }
    
    @Override
    public boolean isAccountNonExpired() {
        return accountNonExpired;
    }
    
    @Override
    public boolean isAccountNonLocked() {
        return accountNonLocked;
    }
    
    @Override
    public boolean isCredentialsNonExpired() {
        return credentialsNonExpired;
    }
    
    @Override
    public boolean isEnabled() {
        return enabled;
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        UserDetailsImpl user = (UserDetailsImpl) o;
        return Objects.equals(id, user.id);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}
JwtUserDetailsService.java
java
package com.example.auth.service;

import com.example.auth.entity.User;
import com.example.auth.repository.UserRepository;
import com.example.auth.repository.UserRoleRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

@Service
public class JwtUserDetailsService implements UserDetailsService {
    
    private static final Logger logger = LoggerFactory.getLogger(JwtUserDetailsService.class);
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private UserRoleRepository userRoleRepository;
    
    @Override
    @Transactional
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = userRepository.findActiveUserByUsername(username)
                .orElseThrow(() -> {
                    logger.error("User not found or not active: {}", username);
                    return new UsernameNotFoundException("User not found: " + username);
                });
        
        List<String> roles = userRoleRepository.findRoleNamesByEmpId(user.getEmpId());
        
        if (roles.isEmpty()) {
            logger.error("No active roles found for user: {}", username);
            throw new UsernameNotFoundException("No active roles found for user: " + username);
        }
        
        logger.debug("User {} loaded with roles: {}", username, roles);
        return UserDetailsImpl.build(user, roles);
    }
    
    public List<String> getUserRoles(String username) {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User not found: " + username));
        
        return userRoleRepository.findRoleNamesByEmpId(user.getEmpId());
    }
    
    public List<String> getUserDirectorates(String username) {
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User not found: " + username));
        
        return userRoleRepository.findDirectoratesByEmpId(user.getEmpId());
    }
    
    public User getUserByUsername(String username) {
        return userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User not found: " + username));
    }
}
DirectorateService.java
java
package com.example.auth.service;

import com.example.auth.repository.UserRepository;
import com.example.auth.repository.UserRoleRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class DirectorateService {
    
    private static final Logger logger = LoggerFactory.getLogger(DirectorateService.class);
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private UserRoleRepository userRoleRepository;
    
    public boolean isValidDirectorateForUser(String username, String directorate) {
        return userRepository.findByUsername(username)
                .map(user -> {
                    boolean hasAccess = userRoleRepository.existsByEmpIdAndDirectorateAndIsActive(
                            user.getEmpId(), directorate);
                    logger.debug("User {} has access to directorate {}: {}", 
                               username, directorate, hasAccess);
                    return hasAccess;
                })
                .orElse(false);
    }
    
    public List<String> getUserDirectorates(String username) {
        return userRepository.findByUsername(username)
                .map(user -> {
                    List<String> directorates = userRoleRepository.findDirectoratesByEmpId(user.getEmpId());
                    logger.debug("User {} has access to directorates: {}", username, directorates);
                    return directorates;
                })
                .orElse(List.of());
    }
}
DTOs
JwtRequest.java
java
package com.example.auth.dto;

import jakarta.validation.constraints.NotBlank;

public class JwtRequest {
    @NotBlank(message = "Username is required")
    private String username;
    
    @NotBlank(message = "Password is required")
    private String password;
    
    // Constructors
    public JwtRequest() {}
    
    public JwtRequest(String username, String password) {
        this.username = username;
        this.password = password;
    }
    
    // Getters and Setters
    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }
    
    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }
}
JwtResponse.java
java
package com.example.auth.dto;

import java.util.List;

public class JwtResponse {
    private String token;
    private String tempToken;
    private String type = "Bearer";
    private Long empId;
    private String username;
    private String email;
    private List<String> roles;
    private List<String> directorates;
    private String selectedDirectorate;
    private boolean requiresDirectorateSelection;
    private String message;
    
    // Constructor for single directorate (direct login)
    public JwtResponse(String token, Long empId, String username, String email, 
                      List<String> roles, String selectedDirectorate) {
        this.token = token;
        this.empId = empId;
        this.username = username;
        this.email = email;
        this.roles = roles;
        this.selectedDirectorate = selectedDirectorate;
        this.requiresDirectorateSelection = false;
    }
    
    // Constructor for multiple directorates (requires selection)
    public JwtResponse(String tempToken, Long empId, String username, String email,
                      List<String> roles, List<String> directorates, String message) {
        this.tempToken = tempToken;
        this.empId = empId;
        this.username = username;
        this.email = email;
        this.roles = roles;
        this.directorates = directorates;
        this.requiresDirectorateSelection = true;
        this.message = message;
    }
    
    // Getters and Setters
    public String getToken() { return token; }
    public void setToken(String token) { this.token = token; }
    
    public String getTempToken() { return tempToken; }
    public void setTempToken(String tempToken) { this.tempToken = tempToken; }
    
    public String getType() { return type; }
    public void setType(String type) { this.type = type; }
    
    public Long getEmpId() { return empId; }
    public void setEmpId(Long empId) { this.empId = empId; }
    
    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }
    
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    
    public List<String> getRoles() { return roles; }
    public void setRoles(List<String> roles) { this.roles = roles; }
    
    public List<String> getDirectorates() { return directorates; }
    public void setDirectorates(List<String> directorates) { this.directorates = directorates; }
    
    public String getSelectedDirectorate() { return selectedDirectorate; }
    public void setSelectedDirectorate(String selectedDirectorate) { this.selectedDirectorate = selectedDirectorate; }
    
    public boolean isRequiresDirectorateSelection() { return requiresDirectorateSelection; }
    public void setRequiresDirectorateSelection(boolean requiresDirectorateSelection) { 
        this.requiresDirectorateSelection = requiresDirectorateSelection; 
    }
    
    public String getMessage() { return message; }
    public void setMessage(String message) { this.message = message; }
}
DirectorateSelectionRequest.java
java
package com.example.auth.dto;

import jakarta.validation.constraints.NotBlank;

public class DirectorateSelectionRequest {
    @NotBlank(message = "Selected directorate is required")
    private String selectedDirectorate;
    
    // Constructors
    public DirectorateSelectionRequest() {}
    
    public DirectorateSelectionRequest(String selectedDirectorate) {
        this.selectedDirectorate = selectedDirectorate;
    }
    
    // Getters and Setters
    public String getSelectedDirectorate() { return selectedDirectorate; }
    public void setSelectedDirectorate(String selectedDirectorate) { this.selectedDirectorate = selectedDirectorate; }
}
MessageResponse.java
java
package com.example.auth.dto;

public class MessageResponse {
    private String message;
    private String status;
    private Object data;
    
    public MessageResponse(String message) {
        this.message = message;
        this.status = "success";
    }
    
    public MessageResponse(String message, String status) {
        this.message = message;
        this.status = status;
    }
    
    public MessageResponse(String message, String status, Object data) {
        this.message = message;
        this.status = status;
        this.data = data;
    }
    
    // Getters and Setters
    public String getMessage() { return message; }
    public void setMessage(String message) { this.message = message; }
    
    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }
    
    public Object getData() { return data; }
    public void setData(Object data) { this.data = data; }
}
Security Configuration
SecurityConfig.java
java
package com.example.auth.config;

import com.example.auth.service.JwtUserDetailsService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true)
public class SecurityConfig {
    
    @Autowired
    private JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint;
    
    @Autowired
    private JwtRequestFilter jwtRequestFilter;
    
    @Autowired
    private JwtUserDetailsService jwtUserDetailsService;
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();
        authProvider.setUserDetailsService(jwtUserDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());
        return authProvider;
    }
    
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
    
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOriginPatterns(Arrays.asList("*"));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(Arrays.asList("*"));
        configuration.setAllowCredentials(true);
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.cors(cors -> cors.configurationSource(corsConfigurationSource()))
                .csrf(AbstractHttpConfigurer::disable)
                .authorizeHttpRequests(authz -> authz
                        .requestMatchers("/api/auth/**").permitAll()
                        .requestMatchers("/actuator/**").permitAll()
                        .requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()
                        .requestMatchers("/api/td/**").hasRole("TD")
                        .requestMatchers("/api/gd/**").hasRole("GD")
                        .anyRequest().authenticated()
                )
                .exceptionHandling(ex -> ex.authenticationEntryPoint(jwtAuthenticationEntryPoint))
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));
        
        http.authenticationProvider(authenticationProvider());
        http.addFilterBefore(jwtRequestFilter, UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
}
JwtAuthenticationEntryPoint.java
java
package com.example.auth.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@Component
public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {
    
    private static final Logger logger = LoggerFactory.getLogger(JwtAuthenticationEntryPoint.class);
    
    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response,
                         AuthenticationException authException) throws IOException {
        
        logger.error("Unauthorized error: {}", authException.getMessage());
        
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        
        final Map<String, Object> body = new HashMap<>();
        body.put("status", HttpServletResponse.SC_UNAUTHORIZED);
        body.put("error", "Unauthorized");
        body.put("message", authException.getMessage());
        body.put("path", request.getServletPath());
        body.put("timestamp", System.currentTimeMillis());
        
        final ObjectMapper mapper = new ObjectMapper();
        mapper.writeValue(response.getOutputStream(), body);
    }
}
JwtRequestFilter.java
java
package com.example.auth.config;

import com.example.auth.service.JwtUserDetailsService;
import com.example.auth.service.JwtUtil;
import io.jsonwebtoken.ExpiredJwtException;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;

@Component
public class JwtRequestFilter extends OncePerRequestFilter {
    
    private static final Logger logger = LoggerFactory.getLogger(JwtRequestFilter.class);
    
    @Autowired
    private JwtUserDetailsService jwtUserDetailsService;
    
    @Autowired
    private JwtUtil jwtUtil;
    
    // Endpoints that allow temporary tokens
    private static final List<String> TEMP_TOKEN_ALLOWED_ENDPOINTS = Arrays.asList(
        "/api/auth/select-directorate",
        "/api/auth/user-directorates"
    );
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, 
                                    FilterChain chain) throws ServletException, IOException {
        
        final String requestTokenHeader = request.getHeader("Authorization");
        final String requestURI = request.getRequestURI();
        
        String username = null;
        String jwtToken = null;
        
        // Skip JWT validation for auth endpoints
        if (requestURI.startsWith("/api/auth/") && !isTempTokenAllowedEndpoint(requestURI)) {
            chain.doFilter(request, response);
            return;
        }
        
        if (requestTokenHeader != null && requestTokenHeader.startsWith("Bearer ")) {
            jwtToken = requestTokenHeader.substring(7);
            try {
                username = jwtUtil.extractUsername(jwtToken);
                
                // Check if it's a temporary token being used on non-allowed endpoints
                if (jwtUtil.isTempToken(jwtToken) && !isTempTokenAllowedEndpoint(requestURI)) {
                    logger.warn("Temporary token used on non-allowed endpoint: {}", requestURI);
                    response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
                    response.setContentType("application/json");
                    response.getWriter().write("{\"error\":\"Please complete directorate selection first\",\"status\":401}");
                    return;
                }
                
            } catch (IllegalArgumentException e) {
                logger.error("Unable to get JWT Token: {}", e.getMessage());
            } catch (ExpiredJwtException e) {
                logger.error("JWT Token has expired: {}", e.getMessage());
            } catch (Exception e) {
                logger.error("JWT Token validation error: {}", e.getMessage());
            }
        }
        
        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            try {
                UserDetails userDetails = this.jwtUserDetailsService.loadUserByUsername(username);
                
                if (jwtUtil.validateToken(jwtToken, userDetails)) {
                    UsernamePasswordAuthenticationToken authToken = 
                            new UsernamePasswordAuthenticationToken(
                                    userDetails, null, userDetails.getAuthorities());
                    authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                    SecurityContextHolder.getContext().setAuthentication(authToken);
                    
                    logger.debug("User {} authenticated successfully", username);
                }
            } catch (Exception e) {
                logger.error("Error authenticating user {}: {}", username, e.getMessage());
            }
        }
        
        chain.doFilter(request, response);
    }
    
    private boolean isTempTokenAllowedEndpoint(String requestURI) {
        return TEMP_TOKEN_ALLOWED_ENDPOINTS.stream()
                .anyMatch(requestURI::startsWith);
    }
}
Controllers
AuthController.java
java
package com.example.auth.controller;

import com.example.auth.dto.DirectorateSelectionRequest;
import com.example.auth.dto.JwtRequest;
import com.example.auth.dto.JwtResponse;
import com.example.auth.dto.MessageResponse;
import com.example.auth.entity.User;
import com.example.auth.service.DirectorateService;
import com.example.auth.service.JwtUserDetailsService;
import com.example.auth.service.JwtUtil;
import com.example.auth.service.UserDetailsImpl;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.DisabledException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/auth")
@CrossOrigin(origins = "*", maxAge = 3600)
public class AuthController {
    
    private static final Logger logger = LoggerFactory.getLogger(AuthController.class);
    
    @Autowired
    private AuthenticationManager authenticationManager;
    
    @Autowired
    private JwtUtil jwtUtil;
    
    @Autowired
    private JwtUserDetailsService userDetailsService;
    
    @Autowired
    private DirectorateService directorateService;
    
    @PostMapping("/signin")
    public ResponseEntity<?> authenticateUser(@Valid @RequestBody JwtRequest loginRequest) {
        try {
            authenticate(loginRequest.getUsername(), loginRequest.getPassword());
            
            final UserDetails userDetails = userDetailsService.loadUserByUsername(loginRequest.getUsername());
            final User user = userDetailsService.getUserByUsername(loginRequest.getUsername());
            final List<String> roles = userDetailsService.getUserRoles(loginRequest.getUsername());
            final List<String> directorates = userDetailsService.getUserDirectorates(loginRequest.getUsername());
            
            UserDetailsImpl userDetailsImpl = (UserDetailsImpl) userDetails;
            
            if (directorates.size() > 1) {
                // Multiple directorates - require selection
                final String tempToken = jwtUtil.generateTempToken(userDetails, roles, directorates);
                return ResponseEntity.ok(new JwtResponse(tempToken, userDetailsImpl.getId(),
                        user.getUsername(), user.getEmail(), roles, directorates, 
                        "Please select a directorate to continue"));
            } else {
                // Single directorate - direct login
                String selectedDirectorate = directorates.get(0);
                final String token = jwtUtil.generateToken(userDetails, roles, selectedDirectorate);
                return ResponseEntity.ok(new JwtResponse(token, userDetailsImpl.getId(),
                        user.getUsername(), user.getEmail(), roles, selectedDirectorate));
            }
            
        } catch (Exception e) {
            logger.error("Authentication failed for user {}: {}", loginRequest.getUsername(), e.getMessage());
            return ResponseEntity.badRequest()
                    .body(new MessageResponse("Authentication failed: " + e.getMessage(), "error"));
        }
    }
    
    @PostMapping("/select-directorate")
    public ResponseEntity<?> selectDirectorate(@Valid @RequestBody DirectorateSelectionRequest request, 
                                              HttpServletRequest httpRequest) {
        try {
            String tempToken = extractTokenFromRequest(httpRequest);
            if (tempToken == null || !jwtUtil.isTempToken(tempToken)) {
                return ResponseEntity.badRequest()
                        .body(new MessageResponse("Invalid or missing temporary token", "error"));
            }
            
            String username = jwtUtil.extractUsername(tempToken);
            List<String> availableDirectorates = jwtUtil.extractDirectorates(tempToken);
            List<String> roles = jwtUtil.extractRoles(tempToken);
            
            // Validate selected directorate
            if (!availableDirectorates.contains(request.getSelectedDirectorate())) {
                return ResponseEntity.badRequest()
                        .body(new MessageResponse("Invalid directorate selection", "error"));
            }
            
            // Verify user has access to selected directorate
            if (!directorateService.isValidDirectorateForUser(username, request.getSelectedDirectorate())) {
                return ResponseEntity.badRequest()
                        .body(new MessageResponse("User does not have access to selected directorate", "error"));
            }
            
            final UserDetails userDetails = userDetailsService.loadUserByUsername(username);
            final User user = userDetailsService.getUserByUsername(username);
            final String finalToken = jwtUtil.generateToken(userDetails, roles, request.getSelectedDirectorate());
            
            UserDetailsImpl userDetailsImpl = (UserDetailsImpl) userDetails;
            
            return ResponseEntity.ok(new JwtResponse(finalToken, userDetailsImpl.getId(),
                    user.getUsername(), user.getEmail(), roles, request.getSelectedDirectorate()));
            
        } catch (Exception e) {
            logger.error("Directorate selection failed: {}", e.getMessage());
            return ResponseEntity.badRequest()
                    .body(new MessageResponse("Directorate selection failed: " + e.getMessage(), "error"));
        }
    }
    
    @GetMapping("/user-directorates")
    public ResponseEntity<?> getUserDirectorates(HttpServletRequest request) {
        try {
            String tempToken = extractTokenFromRequest(request);
            if (tempToken == null || !jwtUtil.isTempToken(tempToken)) {
                return ResponseEntity.badRequest()
                        .body(new MessageResponse("Invalid or missing temporary token", "error"));
            }
            
            String username = jwtUtil.extractUsername(tempToken);
            List<String> directorates = directorateService.getUserDirectorates(username);
            
            Map<String, Object> response = new HashMap<>();
            response.put("username", username);
            response.put("directorates", directorates);
            
            return ResponseEntity.ok(new MessageResponse("Directorates retrieved successfully", "success", response));
            
        } catch (Exception e) {
            logger.error("Failed to get user directorates: {}", e.getMessage());
            return ResponseEntity.badRequest()
                    .body(new MessageResponse("Failed to get user directorates: " + e.getMessage(), "error"));
        }
    }
    
    private void authenticate(String username, String password) throws Exception {
        try {
            authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(username, password));
        } catch (DisabledException e) {
            throw new Exception("USER_DISABLED", e);
        } catch (BadCredentialsException e) {
            throw new Exception("INVALID_CREDENTIALS", e);
        }
    }
    
    private String extractTokenFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
UserController.java
java
package com.example.auth.controller;

import com.example.auth.dto.MessageResponse;
import com.example.auth.service.JwtUtil;
import jakarta.servlet.http.HttpServletRequest;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api")
@CrossOrigin(origins = "*", maxAge = 3600)
public class UserController {
    
    private static final Logger logger = LoggerFactory.getLogger(UserController.class);
    
    @Autowired
    private JwtUtil jwtUtil;
    
    @GetMapping("/test/all")
    public ResponseEntity<?> allAccess() {
        return ResponseEntity.ok(new MessageResponse("Public Content.", "success"));
    }
    
    @GetMapping("/td/dashboard")
    @PreAuthorize("hasRole('TD')")
    public ResponseEntity<?> getTdDashboard(HttpServletRequest request) {
        try {
            String token = extractTokenFromRequest(request);
            
            if (jwtUtil.isTempToken(token)) {
                return ResponseEntity.badRequest()
                        .body(new MessageResponse("Please complete directorate selection first", "error"));
            }
            
            String selectedDirectorate = jwtUtil.extractSelectedDirectorate(token);
            String username = jwtUtil.extractUsername(token);
            Long empId = jwtUtil.extractEmpId(token);
            
            Map<String, Object> dashboardData = new HashMap<>();
            dashboardData.put("message", "Welcome to TD Dashboard");
            dashboardData.put("empId", empId);
            dashboardData.put("username", username);
            dashboardData.put("selectedDirectorate", selectedDirectorate);
            dashboardData.put("data", getTdDataForDirectorate(selectedDirectorate));
            
            logger.info("TD Dashboard accessed by user: {} for directorate: {}", username, selectedDirectorate);
            
            return ResponseEntity.ok(new MessageResponse("TD Dashboard data retrieved successfully", 
                    "success", dashboardData));
            
        } catch (Exception e) {
            logger.error("Error accessing TD dashboard: {}", e.getMessage());
            return ResponseEntity.badRequest()
                    .body(new MessageResponse("Error accessing TD dashboard: " + e.getMessage(), "error"));
        }
    }
    
    @GetMapping("/gd/dashboard")
    @PreAuthorize("hasRole('GD')")
    public ResponseEntity<?> getGdDashboard(HttpServletRequest request) {
        try {
            String token = extractTokenFromRequest(request);
            
            if (jwtUtil.isTempToken(token)) {
                return ResponseEntity.badRequest()
                        .body(new MessageResponse("Please complete directorate selection first", "error"));
            }
            
            String selectedDirectorate = jwtUtil.extractSelectedDirectorate(token);
            String username = jwtUtil.extractUsername(token);
            Long empId = jwtUtil.extractEmpId(token);
            
            Map<String, Object> dashboardData = new HashMap<>();
            dashboardData.put("message", "Welcome to GD Dashboard");
            dashboardData.put("empId", empId);
            dashboardData.put("username", username);
            dashboardData.put("selectedDirectorate", selectedDirectorate);
            dashboardData.put("data", getGdDataForDirectorate(selectedDirectorate));
            
            logger.info("GD Dashboard accessed by user: {} for directorate: {}", username, selectedDirectorate);
            
            return ResponseEntity.ok(new MessageResponse("GD Dashboard data retrieved successfully", 
                    "success", dashboardData));
            
        } catch (Exception e) {
            logger.error("Error accessing GD dashboard: {}", e.getMessage());
            return ResponseEntity.badRequest()
                    .body(new MessageResponse("Error accessing GD dashboard: " + e.getMessage(), "error"));
        }
    }
    
    @GetMapping("/user/profile")
    public ResponseEntity<?> getUserProfile(HttpServletRequest request) {
        try {
            String token = extractTokenFromRequest(request);
            
            if (jwtUtil.isTempToken(token)) {
                return ResponseEntity.badRequest()
                        .body(new MessageResponse("Please complete directorate selection first", "error"));
            }
            
            String username = jwtUtil.extractUsername(token);
            List<String> roles = jwtUtil.extractRoles(token);
            String selectedDirectorate = jwtUtil.extractSelectedDirectorate(token);
            Long empId = jwtUtil.extractEmpId(token);
            
            Map<String, Object> profile = new HashMap<>();
            profile.put("empId", empId);
            profile.put("username", username);
            profile.put("roles", roles);
            profile.put("selectedDirectorate", selectedDirectorate);
            
            return ResponseEntity.ok(new MessageResponse("User profile retrieved successfully", 
                    "success", profile));
            
        } catch (Exception e) {
            logger.error("Error getting user profile: {}", e.getMessage());
            return ResponseEntity.badRequest()
                    .body(new MessageResponse("Error getting user profile: " + e.getMessage(), "error"));
        }
    }
    
    private String extractTokenFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
    
    private Map<String, Object> getTdDataForDirectorate(String directorate) {
        Map<String, Object> data = new HashMap<>();
        data.put("reports", "TD reports for " + directorate);
        data.put("projects", "TD projects in " + directorate);
        data.put("teams", "TD teams under " + directorate);
        data.put("analytics", "TD analytics for " + directorate + " directorate");
        return data;
    }
    
    private Map<String, Object> getGdDataForDirectorate(String directorate) {
        Map<String, Object> data = new HashMap<>();
        data.put("overview", "GD overview for " + directorate);
        data.put("statistics", "GD statistics in " + directorate);
        data.put("operations", "GD operations under " + directorate);
        data.put("performance", "GD performance metrics for " + directorate);
        return data;
    }
}
Database Setup Scripts
MySQL Schema (schema-mysql.sql)
sql
-- Create database
CREATE DATABASE IF NOT EXISTS jwt_auth_db CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
USE jwt_auth_db;

-- Create roles table
CREATE TABLE IF NOT EXISTS roles (
    role_no INT PRIMARY KEY,
    role_name VARCHAR(50) NOT NULL UNIQUE
);

-- Create users table
CREATE TABLE IF NOT EXISTS users (
    emp_id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    enabled BOOLEAN NOT NULL DEFAULT TRUE,
    account_non_expired BOOLEAN NOT NULL DEFAULT TRUE,
    account_non_locked BOOLEAN NOT NULL DEFAULT TRUE,
    credentials_non_expired BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Create user_roles table
CREATE TABLE IF NOT EXISTS user_roles (
    emp_id BIGINT NOT NULL,
    role_no INT NOT NULL,
    role_name VARCHAR(50) NOT NULL,
    directorate VARCHAR(10) NOT NULL,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    PRIMARY KEY (emp_id, role_no, directorate),
    FOREIGN KEY (emp_id) REFERENCES users(emp_id) ON DELETE CASCADE,
    FOREIGN KEY (role_no) REFERENCES roles(role_no) ON DELETE CASCADE
);

-- Create indexes
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_user_roles_emp_id ON user_roles(emp_id);
CREATE INDEX idx_user_roles_directorate ON user_roles(directorate);
CREATE INDEX idx_user_roles_active ON user_roles(is_active);
Oracle Schema (schema-oracle.sql)
sql
-- Create user and grant privileges (run as system user)
-- CREATE USER jwt_user IDENTIFIED BY password;
-- GRANT CONNECT, RESOURCE, CREATE SESSION TO jwt_user;
-- GRANT CREATE TABLE, CREATE VIEW, CREATE PROCEDURE TO jwt_user;

-- Connect as jwt_user

-- Create sequence for users
CREATE SEQUENCE users_seq
    START WITH 1
    INCREMENT BY 1
    NOCACHE
    NOCYCLE;

-- Create roles table
CREATE TABLE roles (
    role_no NUMBER(10) PRIMARY KEY,
    role_name VARCHAR2(50) NOT NULL UNIQUE
);

-- Create users table
CREATE TABLE users (
    emp_id NUMBER(19) PRIMARY KEY,
    username VARCHAR2(50) NOT NULL UNIQUE,
    email VARCHAR2(100) NOT NULL UNIQUE,
    password VARCHAR2(255) NOT NULL,
    first_name VARCHAR2(50),
    last_name VARCHAR2(50),
    enabled NUMBER(1) DEFAULT 1 NOT NULL CHECK (enabled IN (0,1)),
    account_non_expired NUMBER(1) DEFAULT 1 NOT NULL CHECK (account_non_expired IN (0,1)),
    account_non_locked NUMBER(1) DEFAULT 1 NOT NULL CHECK (account_non_locked IN (0,1)),
    credentials_non_expired NUMBER(1) DEFAULT 1 NOT NULL CHECK (credentials_non_expired IN (0,1)),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Create user_roles table
CREATE TABLE user_roles (
    emp_id NUMBER(19) NOT NULL,
    role_no NUMBER(10) NOT NULL,
    role_name VARCHAR2(50) NOT NULL,
    directorate VARCHAR2(10) NOT NULL,
    is_active NUMBER(1) DEFAULT 1 NOT NULL CHECK (is_active IN (0,1)),
    PRIMARY KEY (emp_id, role_no, directorate),
    FOREIGN KEY (emp_id) REFERENCES users(emp_id) ON DELETE CASCADE,
    FOREIGN KEY (role_no) REFERENCES roles(role_no) ON DELETE CASCADE
);

-- Create trigger for auto-increment emp_id
CREATE OR REPLACE TRIGGER users_trigger
    BEFORE INSERT ON users
    FOR EACH ROW
BEGIN
    IF :new.emp_id IS NULL THEN
        :new.emp_id := users_seq.NEXTVAL;
    END IF;
END;

-- Create trigger for updated_at
CREATE OR REPLACE TRIGGER users_updated_at_trigger
    BEFORE UPDATE ON users
    FOR EACH ROW
BEGIN
    :new.updated_at := CURRENT_TIMESTAMP;
END;

-- Create indexes
CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_user_roles_emp_id ON user_roles(emp_id);
CREATE INDEX idx_user_roles_directorate ON user_roles(directorate);
CREATE INDEX idx_user_roles_active ON user_roles(is_active);
Sample Data (data.sql)
sql
-- Insert roles
INSERT INTO roles (role_no, role_name) VALUES (10, 'TD');
INSERT INTO roles (role_no, role_name) VALUES (15, 'GD');

-- Insert users (password is 'password123' encoded with BCrypt)
INSERT INTO users (username, email, password, first_name, last_name) VALUES 
('user1', 'user1@example.com', '$2a$10$slYQmyNdGzTn7ZLBXBChFOC9f6kFjAqPhccnP6DxlWXx2lPk1C3G6', 'John', 'Doe');

INSERT INTO users (username, email, password, first_name, last_name) VALUES 
('user2', 'user2@example.com', '$2a$10$slYQmyNdGzTn7ZLBXBChFOC9f6kFjAqPhccnP6DxlWXx2lPk1C3G6', 'Jane', 'Smith');

INSERT INTO users (username, email, password, first_name, last_name) VALUES 
('admin', 'admin@example.com', '$2a$10$slYQmyNdGzTn7ZLBXBChFOC9f6kFjAqPhccnP6DxlWXx2lPk1C3G6', 'Admin', 'User');

-- Insert user roles
-- user1 has TD role in multiple directorates
INSERT INTO user_roles (emp_id, role_no, role_name, directorate, is_active) VALUES (1, 10, 'TD', 'SDD', 1);
INSERT INTO user_roles (emp_id, role_no, role_name, directorate, is_active) VALUES (1, 10, 'TD', 'CND', 1);

-- user2 has GD role in single directorate
INSERT INTO user_roles (emp_id, role_no, role_name, directorate, is_active) VALUES (2, 15, 'GD', 'SDD', 1);

-- admin has both roles in multiple directorates
INSERT INTO user_roles (emp_id, role_no, role_name, directorate, is_active) VALUES (3, 10, 'TD', 'SDD', 1);
INSERT INTO user_roles (emp_id, role_no, role_name, directorate, is_active) VALUES (3, 15, 'GD', 'CND', 1);
Main Application Class
AuthApplication.java
java
package com.example.auth;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class AuthApplication {
    public static void main(String[] args) {
        SpringApplication.run(AuthApplication.class, args);
    }
}
API Usage Examples
1. Login (Multiple Directorates)
bash
curl -X POST http://localhost:8080/api/auth/signin \
  -H "Content-Type: application/json" \
  -d '{
    "username": "user1",
    "password": "password123"
  }'
Response:

json
{
  "tempToken": "eyJhbGciOiJIUzI1NiJ9...",
  "empId": 1,
  "username": "user1",
  "email": "user1@example.com",
  "roles": ["TD"],
  "directorates": ["SDD", "CND"],
  "requiresDirectorateSelection": true,
  "message": "Please select a directorate to continue"
}
2. Directorate Selection
bash
curl -X POST http://localhost:8080/api/auth/select-directorate \
  -H "Authorization: Bearer TEMP_TOKEN_HERE" \
  -H "Content-Type: application/json" \
  -d '{
    "selectedDirectorate": "SDD"
  }'
3. Access Dashboard
bash
curl -X GET http://localhost:8080/api/td/dashboard \
  -H "Authorization: Bearer FINAL_TOKEN_HERE"
Running the Application
For MySQL:
Start MySQL and create database

Set active profile to mysql in application.yml

Run application: mvn spring-boot:run

For Oracle:
Start Oracle 21c and create user

Set active profile to oracle in application.yml

Run application: mvn spring-boot:run -Dspring.profiles.active=oracle

The application will:

Auto-create tables based on JPA entities

Load sample data from data.sql

Support both databases with appropriate configurations

Handle directorate selection workflow seamlessly

==============================================================================================================================
# Complete Class Structure and Usage Explanation

Let me explain each class in the Spring Boot JWT authentication system and why we use them:

## 1. Entity Classes (Data Model)

### Role.java
**Purpose**: Represents the roles table in database
```java
@Entity
@Table(name = "roles")
public class Role {
    @Id
    @Column(name = "role_no")
    private Integer roleNo;  // Primary key
    
    @Column(name = "role_name")
    private String roleName; // Role name like "TD", "GD"
}
```
**Why we use it**: 
- Maps to database `roles` table
- Stores master role definitions (TD=10, GD=15)
- JPA entity for ORM mapping

### User.java
**Purpose**: Represents the users table in database
```java
@Entity
@Table(name = "users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long empId;        // Auto-generated primary key
    
    private String username;   // Unique username
    private String email;      // Unique email
    private String password;   // Encrypted password
    private Boolean enabled;   // Account status
    // ... other fields
}
```
**Why we use it**:
- Maps to database `users` table
- Stores user account information
- Contains authentication credentials
- Supports account status tracking

### UserRole.java
**Purpose**: Represents the user_roles table (many-to-many relationship)
```java
@Entity
@Table(name = "user_roles")
@IdClass(UserRoleId.class)
public class UserRole {
    @Id private Long empId;         // Foreign key to users
    @Id private Integer roleNo;     // Foreign key to roles
    @Id private String directorate; // Directorate assignment
    
    private String roleName;        // Denormalized role name
    private Boolean isActive;       // Active status
}
```
**Why we use it**:
- Handles many-to-many relationship between users and roles
- Supports multiple directorates per user
- Composite primary key for unique combinations
- Allows role-directorate specific assignments

### UserRoleId.java
**Purpose**: Composite primary key for UserRole entity
```java
public class UserRoleId implements Serializable {
    private Long empId;
    private Integer roleNo;
    private String directorate;
    // equals() and hashCode() methods
}
```
**Why we use it**:
- Required for composite primary keys in JPA
- Ensures uniqueness of (empId, roleNo, directorate) combination
- Implements Serializable for JPA requirements

## 2. Repository Interfaces (Data Access Layer)

### UserRepository.java
**Purpose**: Data access operations for User entity
```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);
    Optional<User> findByEmail(String email);
    Boolean existsByUsername(String username);
    // Custom query methods
}
```
**Why we use it**:
- Provides CRUD operations for User entity
- Custom finder methods for authentication
- Leverages Spring Data JPA auto-implementation
- Type-safe database operations

### UserRoleRepository.java
**Purpose**: Data access operations for UserRole entity
```java
@Repository
public interface UserRoleRepository extends JpaRepository<UserRole, UserRoleId> {
    List<UserRole> findByEmpId(Long empId);
    List<String> findDirectoratesByEmpId(Long empId);
    Boolean existsByEmpIdAndDirectorateAndIsActive(Long empId, String directorate);
    // Custom queries for role and directorate retrieval
}
```
**Why we use it**:
- Manages user-role-directorate relationships
- Custom queries for authorization logic
- Supports directorate-specific data retrieval

### RoleRepository.java
**Purpose**: Data access operations for Role entity
```java
@Repository
public interface RoleRepository extends JpaRepository<Role, Integer> {
    Optional<Role> findByRoleName(String roleName);
    Boolean existsByRoleName(String roleName);
}
```
**Why we use it**:
- Basic CRUD operations for roles
- Role validation and lookup operations

## 3. Service Classes (Business Logic Layer)

### JwtUtil.java
**Purpose**: JWT token creation, parsing, and validation
```java
@Component
public class JwtUtil {
    public String generateToken(UserDetails userDetails, List<String> roles, String selectedDirectorate);
    public String generateTempToken(UserDetails userDetails, List<String> roles, List<String> directorates);
    public String extractUsername(String token);
    public Boolean validateToken(String token, UserDetails userDetails);
    // Token manipulation methods
}
```
**Why we use it**:
- Centralizes JWT operations
- Handles both temporary and final tokens
- Extracts claims from tokens
- Validates token integrity and expiration

### UserDetailsImpl.java
**Purpose**: Custom implementation of Spring Security's UserDetails
```java
public class UserDetailsImpl implements UserDetails {
    private Long id;
    private String username;
    private String password;
    private Collection<? extends GrantedAuthority> authorities;
    // UserDetails interface methods
}
```
**Why we use it**:
- Bridges our User entity with Spring Security
- Provides user information for authentication
- Implements Spring Security's UserDetails contract
- Adds custom fields like empId

### JwtUserDetailsService.java
**Purpose**: Loads user details for authentication
```java
@Service
public class JwtUserDetailsService implements UserDetailsService {
    @Override
    public UserDetails loadUserByUsername(String username) {
        // Load user from database
        // Get user roles
        // Return UserDetailsImpl
    }
}
```
**Why we use it**:
- Implements Spring Security's UserDetailsService
- Loads user data from database during authentication
- Retrieves user roles and authorities
- Required by Spring Security authentication process

### DirectorateService.java
**Purpose**: Business logic for directorate operations
```java
@Service
public class DirectorateService {
    public boolean isValidDirectorateForUser(String username, String directorate);
    public List<String> getUserDirectorates(String username);
}
```
**Why we use it**:
- Validates directorate access permissions
- Retrieves user's available directorates
- Separates directorate logic from controllers

## 4. Configuration Classes (Security Setup)

### SecurityConfig.java
**Purpose**: Spring Security configuration
```java
@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http);
    @Bean
    public PasswordEncoder passwordEncoder();
    @Bean
    public AuthenticationManager authenticationManager();
}
```
**Why we use it**:
- Configures Spring Security settings
- Defines URL access rules
- Sets up authentication providers
- Configures JWT filter chain

### JwtAuthenticationEntryPoint.java
**Purpose**: Handles authentication failures
```java
@Component
public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {
    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response,
                         AuthenticationException authException) {
        // Return JSON error response
    }
}
```
**Why we use it**:
- Customizes authentication error responses
- Returns JSON instead of default HTML error pages
- Provides consistent API error format

### JwtRequestFilter.java
**Purpose**: Intercepts requests to validate JWT tokens
```java
@Component
public class JwtRequestFilter extends OncePerRequestFilter {
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, 
                                    FilterChain chain) {
        // Extract JWT token from header
        // Validate token
        // Set authentication context
    }
}
```
**Why we use it**:
- Validates JWT tokens on each request
- Sets Spring Security authentication context
- Handles temporary token restrictions
- Runs before Spring Security's authentication filters

## 5. DTO Classes (Data Transfer Objects)

### JwtRequest.java
**Purpose**: Login request payload
```java
public class JwtRequest {
    @NotBlank
    private String username;
    @NotBlank
    private String password;
}
```
**Why we use it**:
- Validates login input
- Separates API contract from entity structure
- Provides clean request structure

### JwtResponse.java
**Purpose**: Authentication response payload
```java
public class JwtResponse {
    private String token;           // Final JWT token
    private String tempToken;       // Temporary token for directorate selection
    private String username;
    private List<String> roles;
    private List<String> directorates;
    private boolean requiresDirectorateSelection;
}
```
**Why we use it**:
- Provides structured authentication response
- Handles both single and multi-directorate scenarios
- Separates internal data from API response

### DirectorateSelectionRequest.java
**Purpose**: Directorate selection payload
```java
public class DirectorateSelectionRequest {
    @NotBlank
    private String selectedDirectorate;
}
```
**Why we use it**:
- Validates directorate selection input
- Clean API contract for directorate selection

### MessageResponse.java
**Purpose**: Generic API response wrapper
```java
public class MessageResponse {
    private String message;
    private String status;
    private Object data;
}
```
**Why we use it**:
- Provides consistent API response format
- Wraps success/error messages
- Standardizes response structure

## 6. Controller Classes (API Endpoints)

### AuthController.java
**Purpose**: Authentication and authorization endpoints
```java
@RestController
@RequestMapping("/api/auth")
public class AuthController {
    @PostMapping("/signin")          // Login endpoint
    @PostMapping("/select-directorate") // Directorate selection
    @GetMapping("/user-directorates")   // Get available directorates
}
```
**Why we use it**:
- Handles authentication workflow
- Manages directorate selection process
- Provides public authentication endpoints
- Validates and processes login requests

### UserController.java
**Purpose**: Protected resource endpoints
```java
@RestController
@RequestMapping("/api")
public class UserController {
    @GetMapping("/td/dashboard")    // TD role dashboard
    @GetMapping("/gd/dashboard")    // GD role dashboard
    @GetMapping("/user/profile")    // User profile
}
```
**Why we use it**:
- Provides role-based protected endpoints
- Demonstrates directorate-specific access
- Shows JWT token usage in protected resources

## 7. Main Application Class

### AuthApplication.java
**Purpose**: Spring Boot application entry point
```java
@SpringBootApplication
public class AuthApplication {
    public static void main(String[] args) {
        SpringApplication.run(AuthApplication.class, args);
    }
}
```
**Why we use it**:
- Bootstraps Spring Boot application
- Enables auto-configuration
- Entry point for application startup

## Class Interaction Flow

```
1. User Login Request → AuthController
2. AuthController → AuthenticationManager (Spring Security)
3. AuthenticationManager → JwtUserDetailsService
4. JwtUserDetailsService → UserRepository + UserRoleRepository
5. If multiple directorates → Generate temp token
6. User selects directorate → AuthController
7. AuthController → DirectorateService (validation)
8. Generate final JWT token → JwtUtil
9. Protected resource access → JwtRequestFilter
10. JwtRequestFilter → JwtUtil (token validation)
11. Access granted → UserController
```

Each class has a specific responsibility in the authentication and authorization workflow, following separation of concerns and Spring Boot best practices.

===============================================================


# React Frontend for JWT Authentication with Directorate Selection (Node.js 22 + Ant Design)

## Project Setup

### 1. Initialize React Project
```bash
npx create-react-app jwt-auth-frontend
cd jwt-auth-frontend

# Install dependencies
npm install antd axios react-router-dom @ant-design/icons
npm install @types/node --save-dev  # For Node.js 22 compatibility
```

### 2. Package.json Configuration
```json
{
  "name": "jwt-auth-frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@ant-design/icons": "^5.3.0",
    "@testing-library/jest-dom": "^5.16.4",
    "@testing-library/react": "^13.3.0",
    "@testing-library/user-event": "^13.5.0",
    "antd": "^5.12.0",
    "axios": "^1.6.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.8.0",
    "react-scripts": "5.0.1",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "engines": {
    "node": ">=22.0.0"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}
```

## Project Structure

```
src/
├── components/
│   ├── Login.jsx
│   ├── DirectorateSelection.jsx
│   ├── Dashboard.jsx
│   ├── TDDashboard.jsx
│   ├── GDDashboard.jsx
│   ├── Profile.jsx
│   └── PrivateRoute.jsx
├── services/
│   ├── api.js
│   ├── authService.js
│   └── tokenService.js
├── context/
│   └── AuthContext.jsx
├── utils/
│   └── constants.js
├── styles/
│   └── App.css
├── App.js
└── index.js
```

## Service Files

### 1. src/services/api.js
```javascript
import axios from 'axios';
import { tokenService } from './tokenService';

const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:8080/api';

const api = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor to add token
api.interceptors.request.use(
  (config) => {
    const token = tokenService.getToken();
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Response interceptor to handle errors
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      tokenService.removeToken();
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

export default api;
```

### 2. src/services/tokenService.js
```javascript
class TokenService {
  getToken() {
    return localStorage.getItem('authToken');
  }

  getTempToken() {
    return localStorage.getItem('tempToken');
  }

  setToken(token) {
    localStorage.setItem('authToken', token);
  }

  setTempToken(token) {
    localStorage.setItem('tempToken', token);
  }

  removeToken() {
    localStorage.removeItem('authToken');
    localStorage.removeItem('tempToken');
    localStorage.removeItem('selectedDirectorate');
    localStorage.removeItem('userInfo');
  }

  getUserInfo() {
    const userInfo = localStorage.getItem('userInfo');
    return userInfo ? JSON.parse(userInfo) : null;
  }

  setUserInfo(userInfo) {
    localStorage.setItem('userInfo', JSON.stringify(userInfo));
  }

  getSelectedDirectorate() {
    return localStorage.getItem('selectedDirectorate');
  }

  setSelectedDirectorate(directorate) {
    localStorage.setItem('selectedDirectorate', directorate);
  }

  isAuthenticated() {
    const token = this.getToken();
    if (!token) return false;
    
    try {
      const payload = JSON.parse(atob(token.split('.')[1]));
      return payload.exp > Date.now() / 1000;
    } catch (error) {
      return false;
    }
  }

  hasDirectorateSelected() {
    return !!this.getSelectedDirectorate() && this.isAuthenticated();
  }
}

export const tokenService = new TokenService();
```

### 3. src/services/authService.js
```javascript
import api from './api';
import { tokenService } from './tokenService';

class AuthService {
  async login(username, password) {
    try {
      const response = await api.post('/auth/signin', {
        username,
        password
      });
      
      return response.data;
    } catch (error) {
      throw error.response?.data || { message: 'Login failed' };
    }
  }

  async selectDirectorate(selectedDirectorate) {
    try {
      const tempToken = tokenService.getTempToken();
      const response = await api.post('/auth/select-directorate', 
        { selectedDirectorate },
        { 
          headers: { 
            Authorization: `Bearer ${tempToken}` 
          } 
        }
      );
      
      return response.data;
    } catch (error) {
      throw error.response?.data || { message: 'Directorate selection failed' };
    }
  }

  async getUserDirectorates() {
    try {
      const tempToken = tokenService.getTempToken();
      const response = await api.get('/auth/user-directorates', {
        headers: { 
          Authorization: `Bearer ${tempToken}` 
        }
      });
      
      return response.data;
    } catch (error) {
      throw error.response?.data || { message: 'Failed to get directorates' };
    }
  }

  async getTDDashboard() {
    try {
      const response = await api.get('/td/dashboard');
      return response.data;
    } catch (error) {
      throw error.response?.data || { message: 'Failed to get TD dashboard' };
    }
  }

  async getGDDashboard() {
    try {
      const response = await api.get('/gd/dashboard');
      return response.data;
    } catch (error) {
      throw error.response?.data || { message: 'Failed to get GD dashboard' };
    }
  }

  async getUserProfile() {
    try {
      const response = await api.get('/user/profile');
      return response.data;
    } catch (error) {
      throw error.response?.data || { message: 'Failed to get user profile' };
    }
  }

  logout() {
    tokenService.removeToken();
  }
}

export const authService = new AuthService();
```

## Context

### 4. src/context/AuthContext.jsx
```jsx
import React, { createContext, useContext, useReducer, useEffect } from 'react';
import { tokenService } from '../services/tokenService';

const AuthContext = createContext();

const initialState = {
  isAuthenticated: false,
  user: null,
  selectedDirectorate: null,
  requiresDirectorateSelection: false,
  availableDirectorates: [],
  loading: false
};

function authReducer(state, action) {
  switch (action.type) {
    case 'LOGIN_START':
      return { ...state, loading: true };
    case 'LOGIN_SUCCESS':
      return {
        ...state,
        loading: false,
        isAuthenticated: true,
        user: action.payload.user,
        selectedDirectorate: action.payload.selectedDirectorate,
        requiresDirectorateSelection: false
      };
    case 'LOGIN_REQUIRES_DIRECTORATE':
      return {
        ...state,
        loading: false,
        user: action.payload.user,
        availableDirectorates: action.payload.directorates,
        requiresDirectorateSelection: true
      };
    case 'DIRECTORATE_SELECTED':
      return {
        ...state,
        isAuthenticated: true,
        selectedDirectorate: action.payload.selectedDirectorate,
        requiresDirectorateSelection: false
      };
    case 'LOGOUT':
      return { ...initialState };
    case 'SET_LOADING':
      return { ...state, loading: action.payload };
    default:
      return state;
  }
}

export function AuthProvider({ children }) {
  const [state, dispatch] = useReducer(authReducer, initialState);

  useEffect(() => {
    // Check if user is already authenticated on app load
    if (tokenService.hasDirectorateSelected()) {
      const userInfo = tokenService.getUserInfo();
      const selectedDirectorate = tokenService.getSelectedDirectorate();
      
      if (userInfo && selectedDirectorate) {
        dispatch({
          type: 'LOGIN_SUCCESS',
          payload: {
            user: userInfo,
            selectedDirectorate
          }
        });
      }
    }
  }, []);

  const login = (loginResponse) => {
    if (loginResponse.requiresDirectorateSelection) {
      tokenService.setTempToken(loginResponse.tempToken);
      tokenService.setUserInfo({
        empId: loginResponse.empId,
        username: loginResponse.username,
        email: loginResponse.email,
        roles: loginResponse.roles
      });
      
      dispatch({
        type: 'LOGIN_REQUIRES_DIRECTORATE',
        payload: {
          user: {
            empId: loginResponse.empId,
            username: loginResponse.username,
            email: loginResponse.email,
            roles: loginResponse.roles
          },
          directorates: loginResponse.directorates
        }
      });
    } else {
      tokenService.setToken(loginResponse.token);
      tokenService.setSelectedDirectorate(loginResponse.selectedDirectorate);
      tokenService.setUserInfo({
        empId: loginResponse.empId,
        username: loginResponse.username,
        email: loginResponse.email,
        roles: loginResponse.roles
      });
      
      dispatch({
        type: 'LOGIN_SUCCESS',
        payload: {
          user: {
            empId: loginResponse.empId,
            username: loginResponse.username,
            email: loginResponse.email,
            roles: loginResponse.roles
          },
          selectedDirectorate: loginResponse.selectedDirectorate
        }
      });
    }
  };

  const selectDirectorate = (directorateResponse) => {
    tokenService.setToken(directorateResponse.token);
    tokenService.setSelectedDirectorate(directorateResponse.selectedDirectorate);
    
    dispatch({
      type: 'DIRECTORATE_SELECTED',
      payload: {
        selectedDirectorate: directorateResponse.selectedDirectorate
      }
    });
  };

  const logout = () => {
    tokenService.removeToken();
    dispatch({ type: 'LOGOUT' });
  };

  const setLoading = (loading) => {
    dispatch({ type: 'SET_LOADING', payload: loading });
  };

  return (
    <AuthContext.Provider value={{
      ...state,
      login,
      selectDirectorate,
      logout,
      setLoading
    }}>
      {children}
    </AuthContext.Provider>
  );
}

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};
```

## Components

### 5. src/components/Login.jsx
```jsx
import React, { useState } from 'react';
import { Form, Input, Button, Card, message, Spin } from 'antd';
import { UserOutlined, LockOutlined } from '@ant-design/icons';
import { useAuth } from '../context/AuthContext';
import { authService } from '../services/authService';
import { useNavigate } from 'react-router-dom';

const Login = () => {
  const [form] = Form.useForm();
  const { login, setLoading, loading } = useAuth();
  const navigate = useNavigate();

  const onFinish = async (values) => {
    try {
      setLoading(true);
      const response = await authService.login(values.username, values.password);
      
      login(response);
      
      if (response.requiresDirectorateSelection) {
        message.success('Login successful! Please select your directorate.');
        navigate('/select-directorate');
      } else {
        message.success('Login successful!');
        navigate('/dashboard');
      }
    } catch (error) {
      console.error('Login error:', error);
      message.error(error.message || 'Login failed. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div style={{
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center',
      minHeight: '100vh',
      background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)'
    }}>
      <Card
        title="Login"
        style={{
          width: 400,
          boxShadow: '0 4px 8px rgba(0,0,0,0.1)',
          borderRadius: '10px'
        }}
      >
        <Spin spinning={loading}>
          <Form
            form={form}
            name="login"
            onFinish={onFinish}
            autoComplete="off"
            layout="vertical"
          >
            <Form.Item
              name="username"
              rules={[
                { required: true, message: 'Please input your username!' },
                { min: 3, message: 'Username must be at least 3 characters!' }
              ]}
            >
              <Input 
                prefix={<UserOutlined />} 
                placeholder="Username" 
                size="large"
              />
            </Form.Item>

            <Form.Item
              name="password"
              rules={[
                { required: true, message: 'Please input your password!' },
                { min: 6, message: 'Password must be at least 6 characters!' }
              ]}
            >
              <Input.Password 
                prefix={<LockOutlined />} 
                placeholder="Password" 
                size="large"
              />
            </Form.Item>

            <Form.Item>
              <Button 
                type="primary" 
                htmlType="submit" 
                size="large"
                style={{ width: '100%' }}
                loading={loading}
              >
                Log in
              </Button>
            </Form.Item>
          </Form>
        </Spin>
      </Card>
    </div>
  );
};

export default Login;
```

### 6. src/components/DirectorateSelection.jsx
```jsx
import React, { useState, useEffect } from 'react';
import { Card, Button, List, message, Spin, Typography } from 'antd';
import { BankOutlined, ArrowRightOutlined } from '@ant-design/icons';
import { useAuth } from '../context/AuthContext';
import { authService } from '../services/authService';
import { useNavigate } from 'react-router-dom';

const { Title, Text } = Typography;

const DirectorateSelection = () => {
  const { user, availableDirectorates, selectDirectorate, setLoading, loading } = useAuth();
  const [selectedDirectorate, setSelectedDirectorate] = useState(null);
  const navigate = useNavigate();

  useEffect(() => {
    if (!user || availableDirectorates.length === 0) {
      navigate('/login');
    }
  }, [user, availableDirectorates, navigate]);

  const handleDirectorateSelect = (directorate) => {
    setSelectedDirectorate(directorate);
  };

  const handleContinue = async () => {
    if (!selectedDirectorate) {
      message.warning('Please select a directorate to continue.');
      return;
    }

    try {
      setLoading(true);
      const response = await authService.selectDirectorate(selectedDirectorate);
      
      selectDirectorate(response);
      message.success(`Access granted to ${selectedDirectorate} directorate!`);
      navigate('/dashboard');
    } catch (error) {
      console.error('Directorate selection error:', error);
      message.error(error.message || 'Failed to select directorate. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  if (!user) {
    return null;
  }

  return (
    <div style={{
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center',
      minHeight: '100vh',
      background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
      padding: '20px'
    }}>
      <Card
        style={{
          width: 500,
          boxShadow: '0 4px 8px rgba(0,0,0,0.1)',
          borderRadius: '10px'
        }}
      >
        <Spin spinning={loading}>
          <div style={{ textAlign: 'center', marginBottom: '24px' }}>
            <Title level={3}>Welcome, {user.username}!</Title>
            <Text type="secondary">
              You have access to multiple directorates. Please select one to continue.
            </Text>
          </div>

          <List
            header={<Text strong>Available Directorates:</Text>}
            bordered
            dataSource={availableDirectorates}
            renderItem={(directorate) => (
              <List.Item
                style={{
                  cursor: 'pointer',
                  backgroundColor: selectedDirectorate === directorate ? '#e6f7ff' : 'white',
                  border: selectedDirectorate === directorate ? '2px solid #1890ff' : '1px solid #d9d9d9'
                }}
                onClick={() => handleDirectorateSelect(directorate)}
              >
                <List.Item.Meta
                  avatar={<BankOutlined style={{ fontSize: '18px', color: '#1890ff' }} />}
                  title={directorate}
                  description={`Access ${directorate} directorate resources`}
                />
                {selectedDirectorate === directorate && (
                  <ArrowRightOutlined style={{ color: '#1890ff' }} />
                )}
              </List.Item>
            )}
          />

          <div style={{ marginTop: '24px', textAlign: 'center' }}>
            <Button
              type="primary"
              size="large"
              onClick={handleContinue}
              disabled={!selectedDirectorate}
              loading={loading}
              style={{ minWidth: '120px' }}
            >
              Continue
            </Button>
          </div>
        </Spin>
      </Card>
    </div>
  );
};

export default DirectorateSelection;
```

### 7. src/components/Dashboard.jsx
```jsx
import React, { useEffect } from 'react';
import { Layout, Menu, Button, Dropdown, Avatar, message } from 'antd';
import { 
  UserOutlined, 
  LogoutOutlined, 
  DashboardOutlined,
  ProfileOutlined
} from '@ant-design/icons';
import { useAuth } from '../context/AuthContext';
import { useNavigate, Outlet, useLocation } from 'react-router-dom';

const { Header, Sider, Content } = Layout;

const Dashboard = () => {
  const { user, selectedDirectorate, logout } = useAuth();
  const navigate = useNavigate();
  const location = useLocation();

  useEffect(() => {
    if (!user || !selectedDirectorate) {
      navigate('/login');
    }
  }, [user, selectedDirectorate, navigate]);

  const handleLogout = () => {
    logout();
    message.success('Logged out successfully!');
    navigate('/login');
  };

  const handleMenuClick = ({ key }) => {
    navigate(key);
  };

  const userMenu = (
    <Menu>
      <Menu.Item key="profile" icon={<ProfileOutlined />} onClick={() => navigate('/dashboard/profile')}>
        Profile
      </Menu.Item>
      <Menu.Divider />
      <Menu.Item key="logout" icon={<LogoutOutlined />} onClick={handleLogout}>
        Logout
      </Menu.Item>
    </Menu>
  );

  const getMenuItems = () => {
    const baseItems = [
      {
        key: '/dashboard/profile',
        icon: <ProfileOutlined />,
        label: 'Profile'
      }
    ];

    if (user?.roles?.includes('TD')) {
      baseItems.unshift({
        key: '/dashboard/td',
        icon: <DashboardOutlined />,
        label: 'TD Dashboard'
      });
    }

    if (user?.roles?.includes('GD')) {
      baseItems.unshift({
        key: '/dashboard/gd',
        icon: <DashboardOutlined />,
        label: 'GD Dashboard'
      });
    }

    return baseItems;
  };

  if (!user || !selectedDirectorate) {
    return null;
  }

  return (
    <Layout style={{ minHeight: '100vh' }}>
      <Sider theme="dark" collapsible>
        <div style={{
          height: '64px',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          color: 'white',
          fontSize: '18px',
          fontWeight: 'bold'
        }}>
          {selectedDirectorate}
        </div>
        <Menu
          theme="dark"
          mode="inline"
          selectedKeys={[location.pathname]}
          items={getMenuItems()}
          onClick={handleMenuClick}
        />
      </Sider>
      
      <Layout>
        <Header style={{
          padding: '0 24px',
          background: '#fff',
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          boxShadow: '0 2px 8px rgba(0,0,0,0.1)'
        }}>
          <h2 style={{ margin: 0 }}>Welcome, {user.username}</h2>
          <Dropdown overlay={userMenu} placement="bottomRight">
            <Button type="text" style={{ height: '100%' }}>
              <Avatar icon={<UserOutlined />} style={{ marginRight: '8px' }} />
              {user.username}
            </Button>
          </Dropdown>
        </Header>
        
        <Content style={{
          margin: '24px 16px',
          padding: '24px',
          background: '#fff',
          borderRadius: '6px'
        }}>
          <Outlet />
        </Content>
      </Layout>
    </Layout>
  );
};

export default Dashboard;
```

### 8. src/components/TDDashboard.jsx
```jsx
import React, { useState, useEffect } from 'react';
import { Card, Row, Col, Statistic, Table, Spin, message, Typography } from 'antd';
import { 
  ProjectOutlined, 
  TeamOutlined, 
  FileTextOutlined, 
  BarChartOutlined 
} from '@ant-design/icons';
import { authService } from '../services/authService';
import { useAuth } from '../context/AuthContext';

const { Title } = Typography;

const TDDashboard = () => {
  const [dashboardData, setDashboardData] = useState(null);
  const [loading, setLoading] = useState(true);
  const { selectedDirectorate } = useAuth();

  useEffect(() => {
    fetchDashboardData();
  }, []);

  const fetchDashboardData = async () => {
    try {
      const response = await authService.getTDDashboard();
      setDashboardData(response.data);
    } catch (error) {
      console.error('Dashboard error:', error);
      message.error('Failed to load dashboard data');
    } finally {
      setLoading(false);
    }
  };

  const mockProjects = [
    { key: 1, name: 'Project Alpha', status: 'Active', progress: '75%' },
    { key: 2, name: 'Project Beta', status: 'Planning', progress: '25%' },
    { key: 3, name: 'Project Gamma', status: 'Completed', progress: '100%' },
  ];

  const projectColumns = [
    { title: 'Project Name', dataIndex: 'name', key: 'name' },
    { title: 'Status', dataIndex: 'status', key: 'status' },
    { title: 'Progress', dataIndex: 'progress', key: 'progress' },
  ];

  if (loading) {
    return (
      <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '400px' }}>
        <Spin size="large" />
      </div>
    );
  }

  return (
    <div>
      <Title level={2}>TD Dashboard - {selectedDirectorate}</Title>
      
      <Row gutter={[16, 16]} style={{ marginBottom: '24px' }}>
        <Col xs={24} sm={12} md={6}>
          <Card>
            <Statistic
              title="Active Projects"
              value={12}
              prefix={<ProjectOutlined />}
              valueStyle={{ color: '#3f8600' }}
            />
          </Card>
        </Col>
        <Col xs={24} sm={12} md={6}>
          <Card>
            <Statistic
              title="Team Members"
              value={25}
              prefix={<TeamOutlined />}
              valueStyle={{ color: '#1890ff' }}
            />
          </Card>
        </Col>
        <Col xs={24} sm={12} md={6}>
          <Card>
            <Statistic
              title="Reports"
              value={48}
              prefix={<FileTextOutlined />}
              valueStyle={{ color: '#722ed1' }}
            />
          </Card>
        </Col>
        <Col xs={24} sm={12} md={6}>
          <Card>
            <Statistic
              title="Completion Rate"
              value={87}
              suffix="%"
              prefix={<BarChartOutlined />}
              valueStyle={{ color: '#cf1322' }}
            />
          </Card>
        </Col>
      </Row>

      <Row gutter={[16, 16]}>
        <Col xs={24} lg={16}>
          <Card title="Recent Projects" bordered={false}>
            <Table 
              dataSource={mockProjects} 
              columns={projectColumns} 
              pagination={false}
              size="small"
            />
          </Card>
        </Col>
        <Col xs={24} lg={8}>
          <Card title="Quick Actions" bordered={false}>
            <div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>
              <Card.Grid style={{ width: '100%', textAlign: 'center' }}>
                <ProjectOutlined style={{ fontSize: '24px', color: '#1890ff' }} />
                <div>Create New Project</div>
              </Card.Grid>
              <Card.Grid style={{ width: '100%', textAlign: 'center' }}>
                <FileTextOutlined style={{ fontSize: '24px', color: '#52c41a' }} />
                <div>Generate Report</div>
              </Card.Grid>
              <Card.Grid style={{ width: '100%', textAlign: 'center' }}>
                <TeamOutlined style={{ fontSize: '24px', color: '#faad14' }} />
                <div>Manage Team</div>
              </Card.Grid>
            </div>
          </Card>
        </Col>
      </Row>

      {dashboardData && (
        <Card title="Dashboard Data" style={{ marginTop: '24px' }}>
          <pre style={{ background: '#f5f5f5', padding: '16px', borderRadius: '4px' }}>
            {JSON.stringify(dashboardData, null, 2)}
          </pre>
        </Card>
      )}
    </div>
  );
};

export default TDDashboard;
```

### 9. src/components/GDDashboard.jsx
```jsx
import React, { useState, useEffect } from 'react';
import { Card, Row, Col, Statistic, Progress, Spin, message, Typography } from 'antd';
import { 
  DashboardOutlined, 
  TrophyOutlined, 
  LineChartOutlined, 
  ToolOutlined 
} from '@ant-design/icons';
import { authService } from '../services/authService';
import { useAuth } from '../context/AuthContext';

const { Title } = Typography;

const GDDashboard = () => {
  const [dashboardData, setDashboardData] = useState(null);
  const [loading, setLoading] = useState(true);
  const { selectedDirectorate } = useAuth();

  useEffect(() => {
    fetchDashboardData();
  }, []);

  const fetchDashboardData = async () => {
    try {
      const response = await authService.getGDDashboard();
      setDashboardData(response.data);
    } catch (error) {
      console.error('Dashboard error:', error);
      message.error('Failed to load dashboard data');
    } finally {
      setLoading(false);
    }
  };

  if (loading) {
    return (
      <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '400px' }}>
        <Spin size="large" />
      </div>
    );
  }

  return (
    <div>
      <Title level={2}>GD Dashboard - {selectedDirectorate}</Title>
      
      <Row gutter={[16, 16]} style={{ marginBottom: '24px' }}>
        <Col xs={24} sm={12} md={6}>
          <Card>
            <Statistic
              title="Total Operations"
              value={156}
              prefix={<DashboardOutlined />}
              valueStyle={{ color: '#3f8600' }}
            />
          </Card>
        </Col>
        <Col xs={24} sm={12} md={6}>
          <Card>
            <Statistic
              title="Success Rate"
              value={94.2}
              suffix="%"
              prefix={<TrophyOutlined />}
              valueStyle={{ color: '#1890ff' }}
            />
          </Card>
        </Col>
        <Col xs={24} sm={12} md={6}>
          <Card>
            <Statistic
              title="Performance Score"
              value={8.9}
              suffix="/10"
              prefix={<LineChartOutlined />}
              valueStyle={{ color: '#722ed1' }}
            />
          </Card>
        </Col>
        <Col xs={24} sm={12} md={6}>
          <Card>
            <Statistic
              title="Active Tools"
              value={32}
              prefix={<ToolOutlined />}
              valueStyle={{ color: '#cf1322' }}
            />
          </Card>
        </Col>
      </Row>

      <Row gutter={[16, 16]}>
        <Col xs={24} lg={12}>
          <Card title="Performance Metrics" bordered={false}>
            <div style={{ display: 'flex', flexDirection: 'column', gap: '16px' }}>
              <div>
                <div style={{ marginBottom: '8px' }}>Operations Efficiency</div>
                <Progress percent={89} status="active" strokeColor="#52c41a" />
              </div>
              <div>
                <div style={{ marginBottom: '8px' }}>Resource Utilization</div>
                <Progress percent={76} status="active" strokeColor="#1890ff" />
              </div>
              <div>
                <div style={{ marginBottom: '8px' }}>Quality Index</div>
                <Progress percent={94} status="active" strokeColor="#722ed1" />
              </div>
              <div>
                <div style={{ marginBottom: '8px' }}>Safety Score</div>
                <Progress percent={98} status="active" strokeColor="#faad14" />
              </div>
            </div>
          </Card>
        </Col>
        <Col xs={24} lg={12}>
          <Card title="System Overview" bordered={false}>
            <Row gutter={[8, 8]}>
              <Col span={12}>
                <Card.Grid style={{ width: '100%', textAlign: 'center' }}>
                  <DashboardOutlined style={{ fontSize: '32px', color: '#1890ff' }} />
                  <div style={{ marginTop: '8px' }}>Operations</div>
                  <div style={{ fontSize: '18px', fontWeight: 'bold' }}>156</div>
                </Card.Grid>
              </Col>
              <Col span={12}>
                <Card.Grid style={{ width: '100%', textAlign: 'center' }}>
                  <LineChartOutlined style={{ fontSize: '32px', color: '#52c41a' }} />
                  <div style={{ marginTop: '8px' }}>Analytics</div>
                  <div style={{ fontSize: '18px', fontWeight: 'bold' }}>42</div>
                </Card.Grid>
              </Col>
              <Col span={12}>
                <Card.Grid style={{ width: '100%', textAlign: 'center' }}>
                  <ToolOutlined style={{ fontSize: '32px', color: '#faad14' }} />
                  <div style={{ marginTop: '8px' }}>Tools</div>
                  <div style={{ fontSize: '18px', fontWeight: 'bold' }}>32</div>
                </Card.Grid>
              </Col>
              <Col span={12}>
                <Card.Grid style={{ width: '100%', textAlign: 'center' }}>
                  <TrophyOutlined style={{ fontSize: '32px', color: '#722ed1' }} />
                  <div style={{ marginTop: '8px' }}>Achievements</div>
                  <div style={{ fontSize: '18px', fontWeight: 'bold' }}>15</div>
                </Card.Grid>
              </Col>
            </Row>
          </Card>
        </Col>
      </Row>

      {dashboardData && (
        <Card title="Dashboard Data" style={{ marginTop: '24px' }}>
          <pre style={{ background: '#f5f5f5', padding: '16px', borderRadius: '4px' }}>
            {JSON.stringify(dashboardData, null, 2)}
          </pre>
        </Card>
      )}
    </div>
  );
};

export default GDDashboard;
```

### 10. src/components/Profile.jsx
```jsx
import React, { useState, useEffect } from 'react';
import { Card, Descriptions, Tag, Spin, message, Button, Modal } from 'antd';
import { EditOutlined, UserOutlined } from '@ant-design/icons';
import { useAuth } from '../context/AuthContext';
import { authService } from '../services/authService';

const Profile = () => {
  const [profileData, setProfileData] = useState(null);
  const [loading, setLoading] = useState(true);
  const { user, selectedDirectorate } = useAuth();

  useEffect(() => {
    fetchProfileData();
  }, []);

  const fetchProfileData = async () => {
    try {
      const response = await authService.getUserProfile();
      setProfileData(response.data);
    } catch (error) {
      console.error('Profile error:', error);
      message.error('Failed to load profile data');
    } finally {
      setLoading(false);
    }
  };

  const showEditModal = () => {
    Modal.info({
      title: 'Edit Profile',
      content: 'Profile editing functionality would be implemented here.',
      onOk() {},
    });
  };

  if (loading) {
    return (
      <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '400px' }}>
        <Spin size="large" />
      </div>
    );
  }

  return (
    <div>
      <Card
        title={
          <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
            <span><UserOutlined style={{ marginRight: '8px' }} />User Profile</span>
            <Button type="primary" icon={<EditOutlined />} onClick={showEditModal}>
              Edit Profile
            </Button>
          </div>
        }
        bordered={false}
      >
        <Descriptions column={2} bordered>
          <Descriptions.Item label="Employee ID" span={1}>
            {user?.empId}
          </Descriptions.Item>
          <Descriptions.Item label="Username" span={1}>
            {user?.username}
          </Descriptions.Item>
          <Descriptions.Item label="Email" span={2}>
            {user?.email}
          </Descriptions.Item>
          <Descriptions.Item label="Current Directorate" span={1}>
            <Tag color="blue">{selectedDirectorate}</Tag>
          </Descriptions.Item>
          <Descriptions.Item label="Roles" span={1}>
            {user?.roles?.map(role => (
              <Tag key={role} color="green" style={{ marginBottom: '4px' }}>
                {role}
              </Tag>
            ))}
          </Descriptions.Item>
          <Descriptions.Item label="Account Status" span={1}>
            <Tag color="success">Active</Tag>
          </Descriptions.Item>
          <Descriptions.Item label="Last Login" span={1}>
            {new Date().toLocaleDateString()}
          </Descriptions.Item>
        </Descriptions>

        {profileData && (
          <Card title="Additional Profile Data" style={{ marginTop: '24px' }} size="small">
            <pre style={{ background: '#f5f5f5', padding: '16px', borderRadius: '4px' }}>
              {JSON.stringify(profileData, null, 2)}
            </pre>
          </Card>
        )}
      </Card>
    </div>
  );
};

export default Profile;
```

### 11. src/components/PrivateRoute.jsx
```jsx
import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';

const PrivateRoute = ({ children, requiredRole = null }) => {
  const { isAuthenticated, user, requiresDirectorateSelection } = useAuth();
  const location = useLocation();

  if (!isAuthenticated) {
    if (requiresDirectorateSelection) {
      return <Navigate to="/select-directorate" state={{ from: location }} replace />;
    }
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  if (requiredRole && user?.roles && !user.roles.includes(requiredRole)) {
    return <Navigate to="/dashboard" replace />;
  }

  return children;
};

export default PrivateRoute;
```

## Main App Files

### 12. src/App.js
```jsx
import React from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { ConfigProvider } from 'antd';
import { AuthProvider } from './context/AuthContext';
import PrivateRoute from './components/PrivateRoute';
import Login from './components/Login';
import DirectorateSelection from './components/DirectorateSelection';
import Dashboard from './components/Dashboard';
import TDDashboard from './components/TDDashboard';
import GDDashboard from './components/GDDashboard';
import Profile from './components/Profile';
import './styles/App.css';

function App() {
  return (
    <ConfigProvider
      theme={{
        token: {
          colorPrimary: '#1890ff',
        },
      }}
    >
      <AuthProvider>
        <Router>
          <div className="App">
            <Routes>
              <Route path="/login" element={<Login />} />
              <Route path="/select-directorate" element={<DirectorateSelection />} />
              
              <Route path="/dashboard" element={
                <PrivateRoute>
                  <Dashboard />
                </PrivateRoute>
              }>
                <Route index element={<Navigate to="/dashboard/profile" replace />} />
                <Route path="profile" element={<Profile />} />
                <Route path="td" element={
                  <PrivateRoute requiredRole="TD">
                    <TDDashboard />
                  </PrivateRoute>
                } />
                <Route path="gd" element={
                  <PrivateRoute requiredRole="GD">
                    <GDDashboard />
                  </PrivateRoute>
                } />
              </Route>
              
              <Route path="/" element={<Navigate to="/dashboard" replace />} />
              <Route path="*" element={<Navigate to="/dashboard" replace />} />
            </Routes>
          </div>
        </Router>
      </AuthProvider>
    </ConfigProvider>
  );
}

export default App;
```

### 13. src/styles/App.css
```css
.App {
  text-align: center;
}

.login-form {
  max-width: 300px;
}

.login-form-forgot {
  float: right;
}

.ant-col-rtl .login-form-forgot {
  float: left;
}

.login-form-button {
  width: 100%;
}

/* Custom scrollbar */
::-webkit-scrollbar {
  width: 6px;
}

::-webkit-scrollbar-track {
  background: #f1f1f1;
}

::-webkit-scrollbar-thumb {
  background: #888;
  border-radius: 3px;
}

::-webkit-scrollbar-thumb:hover {
  background: #555;
}

/* Card hover effects */
.ant-card {
  transition: all 0.3s ease;
}

.ant-card:hover {
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

/* Custom button styles */
.ant-btn-primary {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  border: none;
}

.ant-btn-primary:hover {
  background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
}

/* Responsive utilities */
@media (max-width: 768px) {
  .ant-layout-sider {
    display: none;
  }
  
  .ant-layout-content {
    margin: 16px 8px;
    padding: 16px;
  }
}

/* Loading spinner overlay */
.loading-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(255, 255, 255, 0.8);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 9999;
}
```

### 14. src/utils/constants.js
```javascript
export const API_ENDPOINTS = {
  LOGIN: '/auth/signin',
  SELECT_DIRECTORATE: '/auth/select-directorate',
  USER_DIRECTORATES: '/auth/user-directorates',
  TD_DASHBOARD: '/td/dashboard',
  GD_DASHBOARD: '/gd/dashboard',
  USER_PROFILE: '/user/profile'
};

export const ROLES = {
  TD: 'TD',
  GD: 'GD'
};

export const DIRECTORATES = {
  SDD: 'SDD',
  CND: 'CND'
};

export const LOCAL_STORAGE_KEYS = {
  AUTH_TOKEN: 'authToken',
  TEMP_TOKEN: 'tempToken',
  USER_INFO: 'userInfo',
  SELECTED_DIRECTORATE: 'selectedDirectorate'
};
```

### 15. .env
```
REACT_APP_API_URL=http://localhost:8080/api
```

## Running the Application

### 1. Start Backend Server
```bash
# Make sure your Spring Boot application is running on port 8080
mvn spring-boot:run
```

### 2. Start React Application
```bash
# In the React project directory
npm start
```

The application will be available at `http://localhost:3000`

## Features Implemented

- ✅ **JWT Authentication** with automatic token management
- ✅ **Directorate Selection** workflow for multi-directorate users
- ✅ **Role-based Access Control** (TD/GD dashboards)
- ✅ **Responsive Design** with Ant Design components
- ✅ **Protected Routes** with automatic redirects
- ✅ **Context-based State Management** for authentication
- ✅ **Axios Interceptors** for automatic token injection
- ✅ **Error Handling** with user-friendly messages
- ✅ **Loading States** throughout the application
- ✅ **Modern React Patterns** with hooks and functional components

The frontend seamlessly integrates with your Spring Boot JWT authentication backend, providing a complete authentication solution with directorate selection functionality.

[1](https://dev.to/sanjayttg/jwt-authentication-in-react-with-react-router-1d03)
[2](https://www.youtube.com/watch?v=nI8PYZNFtac)
[3](https://clerk.com/blog/adding-jwt-authentication-to-react)
[4](https://permify.co/post/jwt-authentication-in-react/)
[5](https://www.youtube.com/watch?v=27KeYk-5vJw)
[6](https://www.bezkoder.com/react-jwt-auth/)
[7](https://www.youtube.com/watch?v=Ibp-W3cPnbo)
[8](https://developer.okta.com/blog/2019/10/02/jwt-react-auth)
[9](https://stackoverflow.com/questions/41996167/how-to-provide-frontend-with-json-web-token-after-server-authentication)
[10](https://2x.ant.design/components/form/)

====================================================
# File Attachment Management with Attachment Columns in Module Tables

Here's the solution for handling file attachments when each module table has its own attachment columns:

## Database Design

### 1. Module Tables with Attachment Columns
```sql
-- Leave table with attachment columns
CREATE TABLE leave_applications (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    emp_id BIGINT NOT NULL,
    leave_type VARCHAR(50) NOT NULL,
    start_date DATE NOT NULL,
    end_date DATE NOT NULL,
    reason TEXT,
    status VARCHAR(20) DEFAULT 'PENDING',
    
    -- Attachment columns (store filenames/paths)
    medical_certificate VARCHAR(255),
    supporting_document VARCHAR(255),
    additional_attachment VARCHAR(255),
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- LTC table with attachment columns
CREATE TABLE ltc_applications (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    emp_id BIGINT NOT NULL,
    destination VARCHAR(200) NOT NULL,
    travel_date DATE NOT NULL,
    amount DECIMAL(10,2),
    status VARCHAR(20) DEFAULT 'PENDING',
    
    -- Attachment columns
    travel_ticket VARCHAR(255),
    hotel_receipt VARCHAR(255),
    expense_voucher VARCHAR(255),
    travel_certificate VARCHAR(255),
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- TADA table with attachment columns
CREATE TABLE tada_applications (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    emp_id BIGINT NOT NULL,
    purpose VARCHAR(500) NOT NULL,
    from_date DATE NOT NULL,
    to_date DATE NOT NULL,
    total_amount DECIMAL(10,2),
    status VARCHAR(20) DEFAULT 'PENDING',
    
    -- Attachment columns
    travel_bills VARCHAR(255),
    lodging_receipt VARCHAR(255),
    food_receipt VARCHAR(255),
    miscellaneous_receipt VARCHAR(255),
    official_letter VARCHAR(255),
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);
```

## Entity Classes

### 1. Leave Application Entity
```java
package com.example.auth.entity;

import jakarta.persistence.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDate;
import java.time.LocalDateTime;

@Entity
@Table(name = "leave_applications")
public class LeaveApplication {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "emp_id")
    private Long empId;
    
    @Column(name = "leave_type")
    private String leaveType;
    
    @Column(name = "start_date")
    private LocalDate startDate;
    
    @Column(name = "end_date")
    private LocalDate endDate;
    
    private String reason;
    private String status = "PENDING";
    
    // Attachment columns - store file paths/names
    @Column(name = "medical_certificate")
    private String medicalCertificate;
    
    @Column(name = "supporting_document")
    private String supportingDocument;
    
    @Column(name = "additional_attachment")
    private String additionalAttachment;
    
    @CreationTimestamp
    @Column(name = "created_at")
    private LocalDateTime createdAt;
    
    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    // Constructors
    public LeaveApplication() {}
    
    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public Long getEmpId() { return empId; }
    public void setEmpId(Long empId) { this.empId = empId; }
    
    public String getLeaveType() { return leaveType; }
    public void setLeaveType(String leaveType) { this.leaveType = leaveType; }
    
    public LocalDate getStartDate() { return startDate; }
    public void setStartDate(LocalDate startDate) { this.startDate = startDate; }
    
    public LocalDate getEndDate() { return endDate; }
    public void setEndDate(LocalDate endDate) { this.endDate = endDate; }
    
    public String getReason() { return reason; }
    public void setReason(String reason) { this.reason = reason; }
    
    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }
    
    public String getMedicalCertificate() { return medicalCertificate; }
    public void setMedicalCertificate(String medicalCertificate) { this.medicalCertificate = medicalCertificate; }
    
    public String getSupportingDocument() { return supportingDocument; }
    public void setSupportingDocument(String supportingDocument) { this.supportingDocument = supportingDocument; }
    
    public String getAdditionalAttachment() { return additionalAttachment; }
    public void setAdditionalAttachment(String additionalAttachment) { this.additionalAttachment = additionalAttachment; }
    
    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
    
    public LocalDateTime getUpdatedAt() { return updatedAt; }
    public void setUpdatedAt(LocalDateTime updatedAt) { this.updatedAt = updatedAt; }
}
```

### 2. LTC Application Entity
```java
package com.example.auth.entity;

import jakarta.persistence.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Entity
@Table(name = "ltc_applications")
public class LTCApplication {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "emp_id")
    private Long empId;
    
    private String destination;
    
    @Column(name = "travel_date")
    private LocalDate travelDate;
    
    private BigDecimal amount;
    private String status = "PENDING";
    
    // Attachment columns
    @Column(name = "travel_ticket")
    private String travelTicket;
    
    @Column(name = "hotel_receipt")
    private String hotelReceipt;
    
    @Column(name = "expense_voucher")
    private String expenseVoucher;
    
    @Column(name = "travel_certificate")
    private String travelCertificate;
    
    @CreationTimestamp
    @Column(name = "created_at")
    private LocalDateTime createdAt;
    
    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    // Constructors, getters and setters...
    public LTCApplication() {}
    
    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public Long getEmpId() { return empId; }
    public void setEmpId(Long empId) { this.empId = empId; }
    
    public String getDestination() { return destination; }
    public void setDestination(String destination) { this.destination = destination; }
    
    public LocalDate getTravelDate() { return travelDate; }
    public void setTravelDate(LocalDate travelDate) { this.travelDate = travelDate; }
    
    public BigDecimal getAmount() { return amount; }
    public void setAmount(BigDecimal amount) { this.amount = amount; }
    
    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }
    
    public String getTravelTicket() { return travelTicket; }
    public void setTravelTicket(String travelTicket) { this.travelTicket = travelTicket; }
    
    public String getHotelReceipt() { return hotelReceipt; }
    public void setHotelReceipt(String hotelReceipt) { this.hotelReceipt = hotelReceipt; }
    
    public String getExpenseVoucher() { return expenseVoucher; }
    public void setExpenseVoucher(String expenseVoucher) { this.expenseVoucher = expenseVoucher; }
    
    public String getTravelCertificate() { return travelCertificate; }
    public void setTravelCertificate(String travelCertificate) { this.travelCertificate = travelCertificate; }
    
    public LocalDateTime getCreatedAt() { return createdAt; }
    public LocalDateTime getUpdatedAt() { return updatedAt; }
}
```

### 3. TADA Application Entity
```java
package com.example.auth.entity;

import jakarta.persistence.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;

@Entity
@Table(name = "tada_applications")
public class TADAApplication {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "emp_id")
    private Long empId;
    
    private String purpose;
    
    @Column(name = "from_date")
    private LocalDate fromDate;
    
    @Column(name = "to_date")
    private LocalDate toDate;
    
    @Column(name = "total_amount")
    private BigDecimal totalAmount;
    
    private String status = "PENDING";
    
    // Attachment columns
    @Column(name = "travel_bills")
    private String travelBills;
    
    @Column(name = "lodging_receipt")
    private String lodgingReceipt;
    
    @Column(name = "food_receipt")
    private String foodReceipt;
    
    @Column(name = "miscellaneous_receipt")
    private String miscellaneousReceipt;
    
    @Column(name = "official_letter")
    private String officialLetter;
    
    @CreationTimestamp
    @Column(name = "created_at")
    private LocalDateTime createdAt;
    
    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    // Constructors, getters and setters...
    public TADAApplication() {}
    
    // All getters and setters similar to above entities
    // ... (implementation similar to LTCApplication)
}
```

## Service Classes

### 1. Enhanced File Storage Service
```java
package com.example.auth.service;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.UUID;

@Service
public class FileStorageService {
    
    @Value("${app.file.upload-dir:/var/fileserver/uploads}")
    private String uploadDir;
    
    @Value("${app.file.max-file-size:10485760}") // 10MB
    private long maxFileSize;
    
    private static final String[] ALLOWED_EXTENSIONS = {
        ".pdf", ".doc", ".docx", ".jpg", ".jpeg", ".png", ".gif", ".txt"
    };
    
    public String storeFile(MultipartFile file, String moduleType, Long moduleId, String attachmentType) throws IOException {
        // Validate file
        validateFile(file);
        
        // Generate unique filename
        String originalFilename = file.getOriginalFilename();
        String fileExtension = getFileExtension(originalFilename);
        String storedFilename = generateUniqueFilename(originalFilename, fileExtension);
        
        // Create directory structure: /uploads/LEAVE/2024/08/moduleId/
        String dateFolder = LocalDate.now().format(DateTimeFormatter.ofPattern("yyyy/MM"));
        String relativePath = String.format("%s/%s/%d", moduleType, dateFolder, moduleId);
        String fullDirectoryPath = Paths.get(uploadDir, relativePath).toString();
        
        // Create directories if they don't exist
        createDirectoriesIfNotExist(fullDirectoryPath);
        
        // Full file path
        String fullFilePath = Paths.get(fullDirectoryPath, storedFilename).toString();
        
        // Save file
        Path targetLocation = Paths.get(fullFilePath);
        Files.copy(file.getInputStream(), targetLocation);
        
        // Return relative path for database storage
        return String.format("%s/%s", relativePath, storedFilename);
    }
    
    public void deleteFile(String filePath) throws IOException {
        if (filePath != null && !filePath.isEmpty()) {
            Path fileToDelete = Paths.get(uploadDir, filePath);
            Files.deleteIfExists(fileToDelete);
        }
    }
    
    public byte[] loadFile(String filePath) throws IOException {
        Path file = Paths.get(uploadDir, filePath);
        if (Files.exists(file)) {
            return Files.readAllBytes(file);
        }
        throw new IOException("File not found: " + filePath);
    }
    
    public String getFullFilePath(String relativePath) {
        return Paths.get(uploadDir, relativePath).toString();
    }
    
    private void validateFile(MultipartFile file) {
        if (file.isEmpty()) {
            throw new IllegalArgumentException("File is empty");
        }
        
        if (file.getSize() > maxFileSize) {
            throw new IllegalArgumentException("File size exceeds maximum allowed size");
        }
        
        String originalFilename = file.getOriginalFilename();
        if (originalFilename == null) {
            throw new IllegalArgumentException("File name is null");
        }
        
        String fileExtension = getFileExtension(originalFilename).toLowerCase();
        boolean isAllowedExtension = false;
        for (String allowedExt : ALLOWED_EXTENSIONS) {
            if (fileExtension.equals(allowedExt)) {
                isAllowedExtension = true;
                break;
            }
        }
        
        if (!isAllowedExtension) {
            throw new IllegalArgumentException("File type not allowed: " + fileExtension);
        }
    }
    
    private String getFileExtension(String filename) {
        if (filename == null || filename.isEmpty()) {
            return "";
        }
        int lastDotIndex = filename.lastIndexOf('.');
        return lastDotIndex > 0 ? filename.substring(lastDotIndex) : "";
    }
    
    private String generateUniqueFilename(String originalFilename, String extension) {
        String baseName = originalFilename.substring(0, originalFilename.lastIndexOf('.'));
        String timestamp = String.valueOf(System.currentTimeMillis());
        return String.format("%s_%s_%s%s", baseName, timestamp, UUID.randomUUID().toString().substring(0, 8), extension);
    }
    
    private void createDirectoriesIfNotExist(String directoryPath) throws IOException {
        Path path = Paths.get(directoryPath);
        if (!Files.exists(path)) {
            Files.createDirectories(path);
        }
    }
}
```

### 2. Leave Application Service
```java
package com.example.auth.service;

import com.example.auth.entity.LeaveApplication;
import com.example.auth.repository.LeaveApplicationRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@Service
@Transactional
public class LeaveApplicationService {
    
    @Autowired
    private LeaveApplicationRepository leaveApplicationRepository;
    
    @Autowired
    private FileStorageService fileStorageService;
    
    public LeaveApplication saveLeaveApplication(LeaveApplication leaveApplication) {
        return leaveApplicationRepository.save(leaveApplication);
    }
    
    public LeaveApplication saveLeaveApplicationWithAttachments(
            LeaveApplication leaveApplication,
            Map<String, MultipartFile> attachments) throws IOException {
        
        // First save the leave application to get the ID
        LeaveApplication savedApplication = leaveApplicationRepository.save(leaveApplication);
        
        // Then handle attachments
        if (attachments != null && !attachments.isEmpty()) {
            for (Map.Entry<String, MultipartFile> entry : attachments.entrySet()) {
                String attachmentType = entry.getKey();
                MultipartFile file = entry.getValue();
                
                if (file != null && !file.isEmpty()) {
                    String filePath = fileStorageService.storeFile(file, "LEAVE", savedApplication.getId(), attachmentType);
                    
                    // Update the appropriate attachment field
                    updateAttachmentField(savedApplication, attachmentType, filePath);
                }
            }
            
            // Save again with attachment paths
            savedApplication = leaveApplicationRepository.save(savedApplication);
        }
        
        return savedApplication;
    }
    
    public LeaveApplication updateAttachment(Long applicationId, String attachmentType, MultipartFile file) throws IOException {
        LeaveApplication application = leaveApplicationRepository.findById(applicationId)
            .orElseThrow(() -> new RuntimeException("Leave application not found"));
        
        // Delete old file if exists
        String oldFilePath = getAttachmentPath(application, attachmentType);
        if (oldFilePath != null) {
            fileStorageService.deleteFile(oldFilePath);
        }
        
        // Store new file
        String newFilePath = fileStorageService.storeFile(file, "LEAVE", applicationId, attachmentType);
        
        // Update attachment field
        updateAttachmentField(application, attachmentType, newFilePath);
        
        return leaveApplicationRepository.save(application);
    }
    
    public void deleteAttachment(Long applicationId, String attachmentType) throws IOException {
        LeaveApplication application = leaveApplicationRepository.findById(applicationId)
            .orElseThrow(() -> new RuntimeException("Leave application not found"));
        
        // Get current file path
        String filePath = getAttachmentPath(application, attachmentType);
        
        if (filePath != null) {
            // Delete file from storage
            fileStorageService.deleteFile(filePath);
            
            // Update database field to null
            updateAttachmentField(application, attachmentType, null);
            leaveApplicationRepository.save(application);
        }
    }
    
    public byte[] downloadAttachment(Long applicationId, String attachmentType) throws IOException {
        LeaveApplication application = leaveApplicationRepository.findById(applicationId)
            .orElseThrow(() -> new RuntimeException("Leave application not found"));
        
        String filePath = getAttachmentPath(application, attachmentType);
        
        if (filePath == null) {
            throw new RuntimeException("Attachment not found");
        }
        
        return fileStorageService.loadFile(filePath);
    }
    
    public Map<String, String> getAttachments(Long applicationId) {
        LeaveApplication application = leaveApplicationRepository.findById(applicationId)
            .orElseThrow(() -> new RuntimeException("Leave application not found"));
        
        Map<String, String> attachments = new HashMap<>();
        
        if (application.getMedicalCertificate() != null) {
            attachments.put("medicalCertificate", application.getMedicalCertificate());
        }
        if (application.getSupportingDocument() != null) {
            attachments.put("supportingDocument", application.getSupportingDocument());
        }
        if (application.getAdditionalAttachment() != null) {
            attachments.put("additionalAttachment", application.getAdditionalAttachment());
        }
        
        return attachments;
    }
    
    public LeaveApplication getLeaveApplication(Long id) {
        return leaveApplicationRepository.findById(id)
            .orElseThrow(() -> new RuntimeException("Leave application not found"));
    }
    
    private void updateAttachmentField(LeaveApplication application, String attachmentType, String filePath) {
        switch (attachmentType.toLowerCase()) {
            case "medicalcertificate":
            case "medical_certificate":
                application.setMedicalCertificate(filePath);
                break;
            case "supportingdocument":
            case "supporting_document":
                application.setSupportingDocument(filePath);
                break;
            case "additionalattachment":
            case "additional_attachment":
                application.setAdditionalAttachment(filePath);
                break;
            default:
                throw new IllegalArgumentException("Unknown attachment type: " + attachmentType);
        }
    }
    
    private String getAttachmentPath(LeaveApplication application, String attachmentType) {
        switch (attachmentType.toLowerCase()) {
            case "medicalcertificate":
            case "medical_certificate":
                return application.getMedicalCertificate();
            case "supportingdocument":
            case "supporting_document":
                return application.getSupportingDocument();
            case "additionalattachment":
            case "additional_attachment":
                return application.getAdditionalAttachment();
            default:
                return null;
        }
    }
}
```

### 3. LTC Application Service
```java
package com.example.auth.service;

import com.example.auth.entity.LTCApplication;
import com.example.auth.repository.LTCApplicationRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@Service
@Transactional
public class LTCApplicationService {
    
    @Autowired
    private LTCApplicationRepository ltcApplicationRepository;
    
    @Autowired
    private FileStorageService fileStorageService;
    
    public LTCApplication saveLTCApplicationWithAttachments(
            LTCApplication ltcApplication,
            Map<String, MultipartFile> attachments) throws IOException {
        
        // First save the LTC application to get the ID
        LTCApplication savedApplication = ltcApplicationRepository.save(ltcApplication);
        
        // Handle attachments
        if (attachments != null && !attachments.isEmpty()) {
            for (Map.Entry<String, MultipartFile> entry : attachments.entrySet()) {
                String attachmentType = entry.getKey();
                MultipartFile file = entry.getValue();
                
                if (file != null && !file.isEmpty()) {
                    String filePath = fileStorageService.storeFile(file, "LTC", savedApplication.getId(), attachmentType);
                    updateAttachmentField(savedApplication, attachmentType, filePath);
                }
            }
            
            savedApplication = ltcApplicationRepository.save(savedApplication);
        }
        
        return savedApplication;
    }
    
    public LTCApplication updateAttachment(Long applicationId, String attachmentType, MultipartFile file) throws IOException {
        LTCApplication application = ltcApplicationRepository.findById(applicationId)
            .orElseThrow(() -> new RuntimeException("LTC application not found"));
        
        // Delete old file if exists
        String oldFilePath = getAttachmentPath(application, attachmentType);
        if (oldFilePath != null) {
            fileStorageService.deleteFile(oldFilePath);
        }
        
        // Store new file
        String newFilePath = fileStorageService.storeFile(file, "LTC", applicationId, attachmentType);
        updateAttachmentField(application, attachmentType, newFilePath);
        
        return ltcApplicationRepository.save(application);
    }
    
    public Map<String, String> getAttachments(Long applicationId) {
        LTCApplication application = ltcApplicationRepository.findById(applicationId)
            .orElseThrow(() -> new RuntimeException("LTC application not found"));
        
        Map<String, String> attachments = new HashMap<>();
        
        if (application.getTravelTicket() != null) {
            attachments.put("travelTicket", application.getTravelTicket());
        }
        if (application.getHotelReceipt() != null) {
            attachments.put("hotelReceipt", application.getHotelReceipt());
        }
        if (application.getExpenseVoucher() != null) {
            attachments.put("expenseVoucher", application.getExpenseVoucher());
        }
        if (application.getTravelCertificate() != null) {
            attachments.put("travelCertificate", application.getTravelCertificate());
        }
        
        return attachments;
    }
    
    private void updateAttachmentField(LTCApplication application, String attachmentType, String filePath) {
        switch (attachmentType.toLowerCase()) {
            case "travelticket":
            case "travel_ticket":
                application.setTravelTicket(filePath);
                break;
            case "hotelreceipt":
            case "hotel_receipt":
                application.setHotelReceipt(filePath);
                break;
            case "expensevoucher":
            case "expense_voucher":
                application.setExpenseVoucher(filePath);
                break;
            case "travelcertificate":
            case "travel_certificate":
                application.setTravelCertificate(filePath);
                break;
            default:
                throw new IllegalArgumentException("Unknown attachment type: " + attachmentType);
        }
    }
    
    private String getAttachmentPath(LTCApplication application, String attachmentType) {
        switch (attachmentType.toLowerCase()) {
            case "travelticket":
            case "travel_ticket":
                return application.getTravelTicket();
            case "hotelreceipt":
            case "hotel_receipt":
                return application.getHotelReceipt();
            case "expensevoucher":
            case "expense_voucher":
                return application.getExpenseVoucher();
            case "travelcertificate":
            case "travel_certificate":
                return application.getTravelCertificate();
            default:
                return null;
        }
    }
    
    // Other service methods...
}
```

## Controllers

### 1. Leave Application Controller
```java
package com.example.auth.controller;

import com.example.auth.dto.MessageResponse;
import com.example.auth.entity.LeaveApplication;
import com.example.auth.service.LeaveApplicationService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api/leave")
@CrossOrigin(origins = "*", maxAge = 3600)
public class LeaveApplicationController {
    
    @Autowired
    private LeaveApplicationService leaveApplicationService;
    
    @PostMapping("/apply")
    @PreAuthorize("hasRole('TD') or hasRole('GD')")
    public ResponseEntity<?> applyLeave(
            @ModelAttribute LeaveApplication leaveApplication,
            @RequestParam(value = "medicalCertificate", required = false) MultipartFile medicalCertificate,
            @RequestParam(value = "supportingDocument", required = false) MultipartFile supportingDocument,
            @RequestParam(value = "additionalAttachment", required = false) MultipartFile additionalAttachment) {
        
        try {
            Map<String, MultipartFile> attachments = new HashMap<>();
            
            if (medicalCertificate != null && !medicalCertificate.isEmpty()) {
                attachments.put("medicalCertificate", medicalCertificate);
            }
            if (supportingDocument != null && !supportingDocument.isEmpty()) {
                attachments.put("supportingDocument", supportingDocument);
            }
            if (additionalAttachment != null && !additionalAttachment.isEmpty()) {
                attachments.put("additionalAttachment", additionalAttachment);
            }
            
            LeaveApplication savedApplication = leaveApplicationService.saveLeaveApplicationWithAttachments(leaveApplication, attachments);
            
            return ResponseEntity.ok(new MessageResponse("Leave application submitted successfully", "success", savedApplication));
            
        } catch (Exception e) {
            return ResponseEntity.badRequest()
                .body(new MessageResponse("Failed to submit leave application: " + e.getMessage(), "error"));
        }
    }
    
    @PostMapping("/{id}/attachment/{attachmentType}")
    @PreAuthorize("hasRole('TD') or hasRole('GD')")
    public ResponseEntity<?> updateAttachment(
            @PathVariable Long id,
            @PathVariable String attachmentType,
            @RequestParam("file") MultipartFile file) {
        
        try {
            LeaveApplication updatedApplication = leaveApplicationService.updateAttachment(id, attachmentType, file);
            return ResponseEntity.ok(new MessageResponse("Attachment updated successfully", "success", updatedApplication));
            
        } catch (Exception e) {
            return ResponseEntity.badRequest()
                .body(new MessageResponse("Failed to update attachment: " + e.getMessage(), "error"));
        }
    }
    
    @DeleteMapping("/{id}/attachment/{attachmentType}")
    @PreAuthorize("hasRole('TD') or hasRole('GD')")
    public ResponseEntity<?> deleteAttachment(
            @PathVariable Long id,
            @PathVariable String attachmentType) {
        
        try {
            leaveApplicationService.deleteAttachment(id, attachmentType);
            return ResponseEntity.ok(new MessageResponse("Attachment deleted successfully", "success"));
            
        } catch (Exception e) {
            return ResponseEntity.badRequest()
                .body(new MessageResponse("Failed to delete attachment: " + e.getMessage(), "error"));
        }
    }
    
    @GetMapping("/{id}/attachment/{attachmentType}/download")
    @PreAuthorize("hasRole('TD') or hasRole('GD')")
    public ResponseEntity<ByteArrayResource> downloadAttachment(
            @PathVariable Long id,
            @PathVariable String attachmentType) {
        
        try {
            byte[] fileData = leaveApplicationService.downloadAttachment(id, attachmentType);
            ByteArrayResource resource = new ByteArrayResource(fileData);
            
            return ResponseEntity.ok()
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + attachmentType + "_" + id + ".pdf\"")
                .contentType(MediaType.APPLICATION_OCTET_STREAM)
                .contentLength(fileData.length)
                .body(resource);
                
        } catch (Exception e) {
            return ResponseEntity.notFound().build();
        }
    }
    
    @GetMapping("/{id}/attachments")
    @PreAuthorize("hasRole('TD') or hasRole('GD')")
    public ResponseEntity<?> getAttachments(@PathVariable Long id) {
        
        try {
            Map<String, String> attachments = leaveApplicationService.getAttachments(id);
            return ResponseEntity.ok(new MessageResponse("Attachments retrieved successfully", "success", attachments));
            
        } catch (Exception e) {
            return ResponseEntity.badRequest()
                .body(new MessageResponse("Failed to retrieve attachments: " + e.getMessage(), "error"));
        }
    }
    
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('TD') or hasRole('GD')")
    public ResponseEntity<?> getLeaveApplication(@PathVariable Long id) {
        
        try {
            LeaveApplication leaveApplication = leaveApplicationService.getLeaveApplication(id);
            return ResponseEntity.ok(new MessageResponse("Leave application retrieved", "success", leaveApplication));
            
        } catch (Exception e) {
            return ResponseEntity.badRequest()
                .body(new MessageResponse("Failed to retrieve leave application: " + e.getMessage(), "error"));
        }
    }
}
```

## Repository Interfaces

```java
package com.example.auth.repository;

import com.example.auth.entity.LeaveApplication;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface LeaveApplicationRepository extends JpaRepository<LeaveApplication, Long> {
    
    List<LeaveApplication> findByEmpId(Long empId);
    
    List<LeaveApplication> findByStatus(String status);
    
    @Query("SELECT la FROM LeaveApplication la WHERE la.empId = :empId AND la.status = :status")
    List<LeaveApplication> findByEmpIdAndStatus(@Param("empId") Long empId, @Param("status") String status);
}

// Similar repositories for LTCApplicationRepository and TADAApplicationRepository
```

## Configuration

### application.properties
```properties
# File upload configuration
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=50MB

# Custom file storage properties
app.file.upload-dir=/var/fileserver/uploads
app.file.max-file-size=10485760
app.file.allowed-types=pdf,doc,docx,jpg,jpeg,png,gif,txt
```

## Usage Examples

### 1. Submit Leave Application with Attachments
```bash
curl -X POST http://localhost:8080/api/leave/apply \
  -H "Authorization: Bearer YOUR_JWT_TOKEN" \
  -F "empId=1" \
  -F "leaveType=SICK_LEAVE" \
  -F "startDate=2024-09-01" \
  -F "endDate=2024-09-03" \
  -F "reason=Medical treatment" \
  -F "medicalCertificate=@medical_cert.pdf" \
  -F "supportingDocument=@doctor_note.pdf"
```

### 2. Update Specific Attachment
```bash
curl -X POST http://localhost:8080/api/leave/123/attachment/medicalCertificate \
  -H "Authorization: Bearer YOUR_JWT_TOKEN" \
  -F "file=@updated_medical_cert.pdf"
```

### 3. Download Attachment
```bash
curl -X GET http://localhost:8080/api/leave/123/attachment/medicalCertificate/download \
  -H "Authorization: Bearer YOUR_JWT_TOKEN" \
  --output medical_certificate.pdf
```

### 4. Get All Attachments
```bash
curl -X GET http://localhost:8080/api/leave/123/attachments \
  -H "Authorization: Bearer YOUR_JWT_TOKEN"
```

## Benefits of This Approach

1. **Direct Column Mapping**: Each attachment field directly mapped to database column
2. **Module-Specific Logic**: Each module can have its own specific attachment types
3. **Simple Database Structure**: No additional junction tables needed
4. **File Server Storage**: Files stored on file server with paths in database
5. **Individual File Operations**: Upload, update, delete files independently
6. **Type Safety**: Specific attachment types defined per module
7. **Audit Trail**: File paths stored directly with application data
8. **Performance**: Direct column access without joins
9. **Flexibility**: Easy to add new attachment types per module
10. **Security**: Role-based access control for all file operations

This approach provides a clean, efficient way to handle multiple attachments while keeping file paths in the respective module tables and storing actual files on a file server.

=======================================================================================



# One-to-Many Relationship Example: Employee and Dependents with File Attachments

Here's a complete example showing a 1-to-many relationship between Employee and their Dependents, with file attachment support and full CRUD operations:

## Database Schema

```sql
-- Employee table (One side)
CREATE TABLE employees (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    emp_code VARCHAR(20) UNIQUE NOT NULL,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    phone VARCHAR(15),
    department VARCHAR(50),
    designation VARCHAR(50),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- Dependents table (Many side)
CREATE TABLE dependents (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    employee_id BIGINT NOT NULL,  -- Foreign key to employees
    name VARCHAR(100) NOT NULL,
    relationship VARCHAR(20) NOT NULL,  -- 'SPOUSE', 'CHILD', 'PARENT'
    date_of_birth DATE,
    gender VARCHAR(10),
    is_nominee BOOLEAN DEFAULT FALSE,
    
    -- Attachment columns for dependent documents
    birth_certificate VARCHAR(255),
    photo VARCHAR(255),
    identity_proof VARCHAR(255),
    medical_certificate VARCHAR(255),
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    FOREIGN KEY (employee_id) REFERENCES employees(id) ON DELETE CASCADE,
    INDEX idx_employee_dependents (employee_id)
);
```

## Entity Classes

### 1. Employee Entity (One Side)
```java
package com.example.auth.entity;

import com.fasterxml.jackson.annotation.JsonManagedReference;
import jakarta.persistence.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "employees")
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "emp_code", unique = true, nullable = false)
    private String empCode;
    
    @Column(name = "first_name", nullable = false)
    private String firstName;
    
    @Column(name = "last_name", nullable = false)
    private String lastName;
    
    @Column(name = "email", unique = true, nullable = false)
    private String email;
    
    private String phone;
    private String department;
    private String designation;
    
    @CreationTimestamp
    @Column(name = "created_at")
    private LocalDateTime createdAt;
    
    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    // One-to-Many relationship with Dependents
    @OneToMany(mappedBy = "employee", cascade = CascadeType.ALL, fetch = FetchType.LAZY, orphanRemoval = true)
    @JsonManagedReference
    private List<Dependent> dependents = new ArrayList<>();
    
    // Constructors
    public Employee() {}
    
    public Employee(String empCode, String firstName, String lastName, String email) {
        this.empCode = empCode;
        this.firstName = firstName;
        this.lastName = lastName;
        this.email = email;
    }
    
    // Helper methods for managing dependents
    public void addDependent(Dependent dependent) {
        dependents.add(dependent);
        dependent.setEmployee(this);
    }
    
    public void removeDependent(Dependent dependent) {
        dependents.remove(dependent);
        dependent.setEmployee(null);
    }
    
    public void updateDependents(List<Dependent> newDependents) {
        // Clear existing dependents
        this.dependents.clear();
        
        // Add new dependents
        if (newDependents != null) {
            for (Dependent dependent : newDependents) {
                this.addDependent(dependent);
            }
        }
    }
    
    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getEmpCode() { return empCode; }
    public void setEmpCode(String empCode) { this.empCode = empCode; }
    
    public String getFirstName() { return firstName; }
    public void setFirstName(String firstName) { this.firstName = firstName; }
    
    public String getLastName() { return lastName; }
    public void setLastName(String lastName) { this.lastName = lastName; }
    
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    
    public String getPhone() { return phone; }
    public void setPhone(String phone) { this.phone = phone; }
    
    public String getDepartment() { return department; }
    public void setDepartment(String department) { this.department = department; }
    
    public String getDesignation() { return designation; }
    public void setDesignation(String designation) { this.designation = designation; }
    
    public List<Dependent> getDependents() { return dependents; }
    public void setDependents(List<Dependent> dependents) { this.dependents = dependents; }
    
    public LocalDateTime getCreatedAt() { return createdAt; }
    public LocalDateTime getUpdatedAt() { return updatedAt; }
    
    @Override
    public String toString() {
        return "Employee{" +
                "id=" + id +
                ", empCode='" + empCode + '\'' +
                ", firstName='" + firstName + '\'' +
                ", lastName='" + lastName + '\'' +
                ", email='" + email + '\'' +
                '}';
    }
}
```

### 2. Dependent Entity (Many Side)
```java
package com.example.auth.entity;

import com.fasterxml.jackson.annotation.JsonBackReference;
import jakarta.persistence.*;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDate;
import java.time.LocalDateTime;

@Entity
@Table(name = "dependents")
public class Dependent {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "name", nullable = false)
    private String name;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "relationship", nullable = false)
    private RelationshipType relationship;
    
    @Column(name = "date_of_birth")
    private LocalDate dateOfBirth;
    
    @Enumerated(EnumType.STRING)
    private Gender gender;
    
    @Column(name = "is_nominee")
    private Boolean isNominee = false;
    
    // Attachment columns
    @Column(name = "birth_certificate")
    private String birthCertificate;
    
    @Column(name = "photo")
    private String photo;
    
    @Column(name = "identity_proof")
    private String identityProof;
    
    @Column(name = "medical_certificate")
    private String medicalCertificate;
    
    @CreationTimestamp
    @Column(name = "created_at")
    private LocalDateTime createdAt;
    
    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    // Many-to-One relationship with Employee
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "employee_id", nullable = false)
    @JsonBackReference
    private Employee employee;
    
    // Constructors
    public Dependent() {}
    
    public Dependent(String name, RelationshipType relationship) {
        this.name = name;
        this.relationship = relationship;
    }
    
    public Dependent(String name, RelationshipType relationship, LocalDate dateOfBirth, Gender gender) {
        this.name = name;
        this.relationship = relationship;
        this.dateOfBirth = dateOfBirth;
        this.gender = gender;
    }
    
    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public RelationshipType getRelationship() { return relationship; }
    public void setRelationship(RelationshipType relationship) { this.relationship = relationship; }
    
    public LocalDate getDateOfBirth() { return dateOfBirth; }
    public void setDateOfBirth(LocalDate dateOfBirth) { this.dateOfBirth = dateOfBirth; }
    
    public Gender getGender() { return gender; }
    public void setGender(Gender gender) { this.gender = gender; }
    
    public Boolean getIsNominee() { return isNominee; }
    public void setIsNominee(Boolean isNominee) { this.isNominee = isNominee; }
    
    public String getBirthCertificate() { return birthCertificate; }
    public void setBirthCertificate(String birthCertificate) { this.birthCertificate = birthCertificate; }
    
    public String getPhoto() { return photo; }
    public void setPhoto(String photo) { this.photo = photo; }
    
    public String getIdentityProof() { return identityProof; }
    public void setIdentityProof(String identityProof) { this.identityProof = identityProof; }
    
    public String getMedicalCertificate() { return medicalCertificate; }
    public void setMedicalCertificate(String medicalCertificate) { this.medicalCertificate = medicalCertificate; }
    
    public Employee getEmployee() { return employee; }
    public void setEmployee(Employee employee) { this.employee = employee; }
    
    public LocalDateTime getCreatedAt() { return createdAt; }
    public LocalDateTime getUpdatedAt() { return updatedAt; }
    
    @Override
    public String toString() {
        return "Dependent{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", relationship=" + relationship +
                ", dateOfBirth=" + dateOfBirth +
                '}';
    }
}
```

### 3. Enums
```java
package com.example.auth.entity;

public enum RelationshipType {
    SPOUSE("Spouse"),
    CHILD("Child"),
    PARENT("Parent"),
    FATHER("Father"),
    MOTHER("Mother"),
    BROTHER("Brother"),
    SISTER("Sister");
    
    private final String displayName;
    
    RelationshipType(String displayName) {
        this.displayName = displayName;
    }
    
    public String getDisplayName() {
        return displayName;
    }
}

public enum Gender {
    MALE("Male"),
    FEMALE("Female"),
    OTHER("Other");
    
    private final String displayName;
    
    Gender(String displayName) {
        this.displayName = displayName;
    }
    
    public String getDisplayName() {
        return displayName;
    }
}
```

## Repository Interfaces

### 1. Employee Repository
```java
package com.example.auth.repository;

import com.example.auth.entity.Employee;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    
    Optional<Employee> findByEmpCode(String empCode);
    
    Optional<Employee> findByEmail(String email);
    
    List<Employee> findByDepartment(String department);
    
    List<Employee> findByDesignation(String designation);
    
    @Query("SELECT e FROM Employee e LEFT JOIN FETCH e.dependents WHERE e.id = :id")
    Optional<Employee> findByIdWithDependents(@Param("id") Long id);
    
    @Query("SELECT e FROM Employee e LEFT JOIN FETCH e.dependents WHERE e.empCode = :empCode")
    Optional<Employee> findByEmpCodeWithDependents(@Param("empCode") String empCode);
    
    Boolean existsByEmpCode(String empCode);
    
    Boolean existsByEmail(String email);
}
```

### 2. Dependent Repository
```java
package com.example.auth.repository;

import com.example.auth.entity.Dependent;
import com.example.auth.entity.RelationshipType;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface DependentRepository extends JpaRepository<Dependent, Long> {
    
    List<Dependent> findByEmployeeId(Long employeeId);
    
    List<Dependent> findByEmployeeIdAndRelationship(Long employeeId, RelationshipType relationship);
    
    List<Dependent> findByEmployeeIdAndIsNominee(Long employeeId, Boolean isNominee);
    
    @Query("SELECT COUNT(d) FROM Dependent d WHERE d.employee.id = :employeeId")
    Long countByEmployeeId(@Param("employeeId") Long employeeId);
    
    @Query("SELECT d FROM Dependent d WHERE d.employee.id = :employeeId AND d.relationship = :relationship")
    List<Dependent> findDependentsByEmployeeAndRelationship(@Param("employeeId") Long employeeId, 
                                                           @Param("relationship") RelationshipType relationship);
    
    void deleteByEmployeeId(Long employeeId);
}
```

## Service Classes

### 1. Employee Service
```java
package com.example.auth.service;

import com.example.auth.entity.Employee;
import com.example.auth.entity.Dependent;
import com.example.auth.repository.EmployeeRepository;
import com.example.auth.repository.DependentRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.util.List;
import java.util.Map;

@Service
@Transactional
public class EmployeeService {
    
    @Autowired
    private EmployeeRepository employeeRepository;
    
    @Autowired
    private DependentRepository dependentRepository;
    
    @Autowired
    private FileStorageService fileStorageService;
    
    public Employee saveEmployee(Employee employee) {
        return employeeRepository.save(employee);
    }
    
    public Employee saveEmployeeWithDependents(Employee employee) {
        // Save employee first
        Employee savedEmployee = employeeRepository.save(employee);
        
        // Process dependents if present
        if (employee.getDependents() != null && !employee.getDependents().isEmpty()) {
            for (Dependent dependent : employee.getDependents()) {
                dependent.setEmployee(savedEmployee);
            }
            dependentRepository.saveAll(employee.getDependents());
        }
        
        return savedEmployee;
    }
    
    public Employee updateEmployee(Long employeeId, Employee employeeDetails) {
        Employee existingEmployee = employeeRepository.findById(employeeId)
            .orElseThrow(() -> new RuntimeException("Employee not found with id: " + employeeId));
        
        // Update employee fields
        existingEmployee.setFirstName(employeeDetails.getFirstName());
        existingEmployee.setLastName(employeeDetails.getLastName());
        existingEmployee.setEmail(employeeDetails.getEmail());
        existingEmployee.setPhone(employeeDetails.getPhone());
        existingEmployee.setDepartment(employeeDetails.getDepartment());
        existingEmployee.setDesignation(employeeDetails.getDesignation());
        
        return employeeRepository.save(existingEmployee);
    }
    
    public Employee updateEmployeeWithDependents(Long employeeId, Employee employeeDetails) {
        Employee existingEmployee = employeeRepository.findByIdWithDependents(employeeId)
            .orElseThrow(() -> new RuntimeException("Employee not found with id: " + employeeId));
        
        // Update employee fields
        existingEmployee.setFirstName(employeeDetails.getFirstName());
        existingEmployee.setLastName(employeeDetails.getLastName());
        existingEmployee.setEmail(employeeDetails.getEmail());
        existingEmployee.setPhone(employeeDetails.getPhone());
        existingEmployee.setDepartment(employeeDetails.getDepartment());
        existingEmployee.setDesignation(employeeDetails.getDesignation());
        
        // Update dependents
        if (employeeDetails.getDependents() != null) {
            // Remove existing dependents that are not in the new list
            existingEmployee.getDependents().clear();
            
            // Add new dependents
            for (Dependent newDependent : employeeDetails.getDependents()) {
                newDependent.setEmployee(existingEmployee);
                existingEmployee.addDependent(newDependent);
            }
        }
        
        return employeeRepository.save(existingEmployee);
    }
    
    public Employee getEmployeeById(Long id) {
        return employeeRepository.findById(id)
            .orElseThrow(() -> new RuntimeException("Employee not found with id: " + id));
    }
    
    public Employee getEmployeeWithDependents(Long id) {
        return employeeRepository.findByIdWithDependents(id)
            .orElseThrow(() -> new RuntimeException("Employee not found with id: " + id));
    }
    
    public Employee getEmployeeByEmpCode(String empCode) {
        return employeeRepository.findByEmpCode(empCode)
            .orElseThrow(() -> new RuntimeException("Employee not found with empCode: " + empCode));
    }
    
    public List<Employee> getAllEmployees() {
        return employeeRepository.findAll();
    }
    
    public List<Employee> getEmployeesByDepartment(String department) {
        return employeeRepository.findByDepartment(department);
    }
    
    public void deleteEmployee(Long id) {
        if (!employeeRepository.existsById(id)) {
            throw new RuntimeException("Employee not found with id: " + id);
        }
        employeeRepository.deleteById(id);
    }
    
    public boolean existsByEmpCode(String empCode) {
        return employeeRepository.existsByEmpCode(empCode);
    }
    
    public boolean existsByEmail(String email) {
        return employeeRepository.existsByEmail(email);
    }
}
```

### 2. Dependent Service
```java
package com.example.auth.service;

import com.example.auth.entity.Dependent;
import com.example.auth.entity.Employee;
import com.example.auth.entity.RelationshipType;
import com.example.auth.repository.DependentRepository;
import com.example.auth.repository.EmployeeRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Service
@Transactional
public class DependentService {
    
    @Autowired
    private DependentRepository dependentRepository;
    
    @Autowired
    private EmployeeRepository employeeRepository;
    
    @Autowired
    private FileStorageService fileStorageService;
    
    public Dependent saveDependent(Long employeeId, Dependent dependent) {
        Employee employee = employeeRepository.findById(employeeId)
            .orElseThrow(() -> new RuntimeException("Employee not found with id: " + employeeId));
        
        dependent.setEmployee(employee);
        return dependentRepository.save(dependent);
    }
    
    public Dependent saveDependentWithAttachments(Long employeeId, Dependent dependent, 
                                                Map<String, MultipartFile> attachments) throws IOException {
        
        // First save the dependent
        Dependent savedDependent = saveDependent(employeeId, dependent);
        
        // Handle attachments
        if (attachments != null && !attachments.isEmpty()) {
            for (Map.Entry<String, MultipartFile> entry : attachments.entrySet()) {
                String attachmentType = entry.getKey();
                MultipartFile file = entry.getValue();
                
                if (file != null && !file.isEmpty()) {
                    String filePath = fileStorageService.storeFile(file, "DEPENDENT", savedDependent.getId(), attachmentType);
                    updateAttachmentField(savedDependent, attachmentType, filePath);
                }
            }
            
            savedDependent = dependentRepository.save(savedDependent);
        }
        
        return savedDependent;
    }
    
    public Dependent updateDependent(Long dependentId, Dependent dependentDetails) {
        Dependent existingDependent = dependentRepository.findById(dependentId)
            .orElseThrow(() -> new RuntimeException("Dependent not found with id: " + dependentId));
        
        // Update dependent fields
        existingDependent.setName(dependentDetails.getName());
        existingDependent.setRelationship(dependentDetails.getRelationship());
        existingDependent.setDateOfBirth(dependentDetails.getDateOfBirth());
        existingDependent.setGender(dependentDetails.getGender());
        existingDependent.setIsNominee(dependentDetails.getIsNominee());
        
        return dependentRepository.save(existingDependent);
    }
    
    public Dependent updateDependentWithAttachments(Long dependentId, Dependent dependentDetails,
                                                   Map<String, MultipartFile> attachments) throws IOException {
        
        Dependent updatedDependent = updateDependent(dependentId, dependentDetails);
        
        // Handle attachment updates
        if (attachments != null && !attachments.isEmpty()) {
            for (Map.Entry<String, MultipartFile> entry : attachments.entrySet()) {
                String attachmentType = entry.getKey();
                MultipartFile file = entry.getValue();
                
                if (file != null && !file.isEmpty()) {
                    // Delete old file if exists
                    String oldFilePath = getAttachmentPath(updatedDependent, attachmentType);
                    if (oldFilePath != null) {
                        fileStorageService.deleteFile(oldFilePath);
                    }
                    
                    // Store new file
                    String filePath = fileStorageService.storeFile(file, "DEPENDENT", dependentId, attachmentType);
                    updateAttachmentField(updatedDependent, attachmentType, filePath);
                }
            }
            
            updatedDependent = dependentRepository.save(updatedDependent);
        }
        
        return updatedDependent;
    }
    
    public Dependent updateDependentAttachment(Long dependentId, String attachmentType, MultipartFile file) throws IOException {
        Dependent dependent = dependentRepository.findById(dependentId)
            .orElseThrow(() -> new RuntimeException("Dependent not found with id: " + dependentId));
        
        // Delete old file if exists
        String oldFilePath = getAttachmentPath(dependent, attachmentType);
        if (oldFilePath != null) {
            fileStorageService.deleteFile(oldFilePath);
        }
        
        // Store new file
        String newFilePath = fileStorageService.storeFile(file, "DEPENDENT", dependentId, attachmentType);
        updateAttachmentField(dependent, attachmentType, newFilePath);
        
        return dependentRepository.save(dependent);
    }
    
    public void deleteDependentAttachment(Long dependentId, String attachmentType) throws IOException {
        Dependent dependent = dependentRepository.findById(dependentId)
            .orElseThrow(() -> new RuntimeException("Dependent not found with id: " + dependentId));
        
        String filePath = getAttachmentPath(dependent, attachmentType);
        if (filePath != null) {
            fileStorageService.deleteFile(filePath);
            updateAttachmentField(dependent, attachmentType, null);
            dependentRepository.save(dependent);
        }
    }
    
    public byte[] downloadDependentAttachment(Long dependentId, String attachmentType) throws IOException {
        Dependent dependent = dependentRepository.findById(dependentId)
            .orElseThrow(() -> new RuntimeException("Dependent not found with id: " + dependentId));
        
        String filePath = getAttachmentPath(dependent, attachmentType);
        if (filePath == null) {
            throw new RuntimeException("Attachment not found");
        }
        
        return fileStorageService.loadFile(filePath);
    }
    
    public List<Dependent> getDependentsByEmployeeId(Long employeeId) {
        return dependentRepository.findByEmployeeId(employeeId);
    }
    
    public List<Dependent> getDependentsByEmployeeAndRelationship(Long employeeId, RelationshipType relationship) {
        return dependentRepository.findByEmployeeIdAndRelationship(employeeId, relationship);
    }
    
    public Dependent getDependentById(Long id) {
        return dependentRepository.findById(id)
            .orElseThrow(() -> new RuntimeException("Dependent not found with id: " + id));
    }
    
    public void deleteDependent(Long id) {
        Dependent dependent = dependentRepository.findById(id)
            .orElseThrow(() -> new RuntimeException("Dependent not found with id: " + id));
        
        // Delete associated files
        try {
            if (dependent.getBirthCertificate() != null) {
                fileStorageService.deleteFile(dependent.getBirthCertificate());
            }
            if (dependent.getPhoto() != null) {
                fileStorageService.deleteFile(dependent.getPhoto());
            }
            if (dependent.getIdentityProof() != null) {
                fileStorageService.deleteFile(dependent.getIdentityProof());
            }
            if (dependent.getMedicalCertificate() != null) {
                fileStorageService.deleteFile(dependent.getMedicalCertificate());
            }
        } catch (IOException e) {
            // Log error but continue with deletion
            System.err.println("Error deleting files for dependent " + id + ": " + e.getMessage());
        }
        
        dependentRepository.deleteById(id);
    }
    
    public Long getDependentCountByEmployeeId(Long employeeId) {
        return dependentRepository.countByEmployeeId(employeeId);
    }
    
    public Map<String, String> getDependentAttachments(Long dependentId) {
        Dependent dependent = dependentRepository.findById(dependentId)
            .orElseThrow(() -> new RuntimeException("Dependent not found with id: " + dependentId));
        
        Map<String, String> attachments = new HashMap<>();
        
        if (dependent.getBirthCertificate() != null) {
            attachments.put("birthCertificate", dependent.getBirthCertificate());
        }
        if (dependent.getPhoto() != null) {
            attachments.put("photo", dependent.getPhoto());
        }
        if (dependent.getIdentityProof() != null) {
            attachments.put("identityProof", dependent.getIdentityProof());
        }
        if (dependent.getMedicalCertificate() != null) {
            attachments.put("medicalCertificate", dependent.getMedicalCertificate());
        }
        
        return attachments;
    }
    
    private void updateAttachmentField(Dependent dependent, String attachmentType, String filePath) {
        switch (attachmentType.toLowerCase()) {
            case "birthcertificate":
            case "birth_certificate":
                dependent.setBirthCertificate(filePath);
                break;
            case "photo":
                dependent.setPhoto(filePath);
                break;
            case "identityproof":
            case "identity_proof":
                dependent.setIdentityProof(filePath);
                break;
            case "medicalcertificate":
            case "medical_certificate":
                dependent.setMedicalCertificate(filePath);
                break;
            default:
                throw new IllegalArgumentException("Unknown attachment type: " + attachmentType);
        }
    }
    
    private String getAttachmentPath(Dependent dependent, String attachmentType) {
        switch (attachmentType.toLowerCase()) {
            case "birthcertificate":
            case "birth_certificate":
                return dependent.getBirthCertificate();
            case "photo":
                return dependent.getPhoto();
            case "identityproof":
            case "identity_proof":
                return dependent.getIdentityProof();
            case "medicalcertificate":
            case "medical_certificate":
                return dependent.getMedicalCertificate();
            default:
                return null;
        }
    }
}
```

## Controllers

### 1. Employee Controller
```java
package com.example.auth.controller;

import com.example.auth.dto.MessageResponse;
import com.example.auth.entity.Employee;
import com.example.auth.service.EmployeeService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/employees")
@CrossOrigin(origins = "*", maxAge = 3600)
public class EmployeeController {
    
    @Autowired
    private EmployeeService employeeService;
    
    @PostMapping
    @PreAuthorize("hasRole('TD') or hasRole('GD')")
    public ResponseEntity<?> createEmployee(@RequestBody Employee employee) {
        try {
            // Check if empCode already exists
            if (employeeService.existsByEmpCode(employee.getEmpCode())) {
                return ResponseEntity.badRequest()
                    .body(new MessageResponse("Employee code already exists", "error"));
            }
            
            // Check if email already exists
            if (employeeService.existsByEmail(employee.getEmail())) {
                return ResponseEntity.badRequest()
                    .body(new MessageResponse("Email already exists", "error"));
            }
            
            Employee savedEmployee = employeeService.saveEmployeeWithDependents(employee);
            return ResponseEntity.ok(new MessageResponse("Employee created successfully", "success", savedEmployee));
            
        } catch (Exception e) {
            return ResponseEntity.badRequest()
                .body(new MessageResponse("Failed to create employee: " + e.getMessage(), "error"));
        }
    }
    
    @GetMapping
    @PreAuthorize("hasRole('TD') or hasRole('GD')")
    public ResponseEntity<?> getAllEmployees() {
        try {
            List<Employee> employees = employeeService.getAllEmployees();
            return ResponseEntity.ok(new MessageResponse("Employees retrieved successfully", "success", employees));
            
        } catch (Exception e) {
            return ResponseEntity.badRequest()
                .body(new MessageResponse("Failed to retrieve employees: " + e.getMessage(), "error"));
        }
    }
    
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('TD') or hasRole('GD')")
    public ResponseEntity<?> getEmployeeById(@PathVariable Long id) {
        try {
            Employee employee = employeeService.getEmployeeById(id);
            return ResponseEntity.ok(new MessageResponse("Employee retrieved successfully", "success", employee));
            
        } catch (Exception e) {
            return ResponseEntity.badRequest()
                .body(new MessageResponse("Employee not found: " + e.getMessage(), "error"));
        }
    }
    
    @GetMapping("/{id}/with-dependents")
    @PreAuthorize("hasRole('TD') or hasRole('GD')")
    public ResponseEntity<?> getEmployeeWithDependents(@PathVariable Long id) {
        try {
            Employee employee = employeeService.getEmployeeWithDependents(id);
            return ResponseEntity.ok(new MessageResponse("Employee with dependents retrieved successfully", "success", employee));
            
        } catch (Exception e) {
            return ResponseEntity.badRequest()
                .body(new MessageResponse("Employee not found: " + e.getMessage(), "error"));
        }
    }
    
    @GetMapping("/code/{empCode}")
    @PreAuthorize("hasRole('TD') or hasRole('GD')")
    public ResponseEntity<?> getEmployeeByEmpCode(@PathVariable String empCode) {
        try {
            Employee employee = employeeService.getEmployeeByEmpCode(empCode);
            return ResponseEntity.ok(new MessageResponse("Employee retrieved successfully", "success", employee));
            
        } catch (Exception e) {
            return ResponseEntity.badRequest()
                .body(new MessageResponse("Employee not found: " + e.getMessage(), "error"));
        }
    }
    
    @GetMapping("/department/{department}")
    @PreAuthorize("hasRole('TD') or hasRole('GD')")
    public ResponseEntity<?> getEmployeesByDepartment(@PathVariable String department) {
        try {
            List<Employee> employees = employeeService.getEmployeesByDepartment(department);
            return ResponseEntity.ok(new MessageResponse("Employees retrieved successfully", "success", employees));
            
        } catch (Exception e) {
            return ResponseEntity.badRequest()
                .body(new MessageResponse("Failed to retrieve employees: " + e.getMessage(), "error"));
        }
    }
    
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('TD') or hasRole('GD')")
    public ResponseEntity<?> updateEmployee(@PathVariable Long id, @RequestBody Employee employeeDetails) {
        try {
            Employee updatedEmployee = employeeService.updateEmployee(id, employeeDetails);
            return ResponseEntity.ok(new MessageResponse("Employee updated successfully", "success", updatedEmployee));
            
        } catch (Exception e) {
            return ResponseEntity.badRequest()
                .body(new MessageResponse("Failed to update employee: " + e.getMessage(), "error"));
        }
    }
    
    @PutMapping("/{id}/with-dependents")
    @PreAuthorize("hasRole('TD') or hasRole('GD')")
    public ResponseEntity<?> updateEmployeeWithDependents(@PathVariable Long id, @RequestBody Employee employeeDetails) {
        try {
            Employee updatedEmployee = employeeService.updateEmployeeWithDependents(id, employeeDetails);
            return ResponseEntity.ok(new MessageResponse("Employee with dependents updated successfully", "success", updatedEmployee));
            
        } catch (Exception e) {
            return ResponseEntity.badRequest()
                .body(new MessageResponse("Failed to update employee: " + e.getMessage(), "error"));
        }
    }
    
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('TD') or hasRole('GD')")
    public ResponseEntity<?> deleteEmployee(@PathVariable Long id) {
        try {
            employeeService.deleteEmployee(id);
            return ResponseEntity.ok(new MessageResponse("Employee deleted successfully", "success"));
            
        } catch (Exception e) {
            return ResponseEntity.badRequest()
                .body(new MessageResponse("Failed to delete employee: " + e.getMessage(), "error"));
        }
    }
}
```

### 2. Dependent Controller
```java
package com.example.auth.controller;

import com.example.auth.dto.MessageResponse;
import com.example.auth.entity.Dependent;
import com.example.auth.entity.RelationshipType;
import com.example.auth.service.DependentService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/dependents")
@CrossOrigin(origins = "*", maxAge = 3600)
public class DependentController {
    
    @Autowired
    private DependentService dependentService;
    
    @PostMapping("/employee/{employeeId}")
    @PreAuthorize("hasRole('TD') or hasRole('GD')")
    public ResponseEntity<?> createDependent(
            @PathVariable Long employeeId,
            @ModelAttribute Dependent dependent,
            @RequestParam(value = "birthCertificate", required = false) MultipartFile birthCertificate,
            @RequestParam(value = "photo", required = false) MultipartFile photo,
            @RequestParam(value = "identityProof", required = false) MultipartFile identityProof,
            @RequestParam(value = "medicalCertificate", required = false) MultipartFile medicalCertificate) {
        
        try {
            Map<String, MultipartFile> attachments = new HashMap<>();
            
            if (birthCertificate != null && !birthCertificate.isEmpty()) {
                attachments.put("birthCertificate", birthCertificate);
            }
            if (photo != null && !photo.isEmpty()) {
                attachments.put("photo", photo);
            }
            if (identityProof != null && !identityProof.isEmpty()) {
                attachments.put("identityProof", identityProof);
            }
            if (medicalCertificate != null && !medicalCertificate.isEmpty()) {
                attachments.put("medicalCertificate", medicalCertificate);
            }
            
            Dependent savedDependent = dependentService.saveDependentWithAttachments(employeeId, dependent, attachments);
            return ResponseEntity.ok(new MessageResponse("Dependent created successfully", "success", savedDependent));
            
        } catch (Exception e) {
            return ResponseEntity.badRequest()
                .body(new MessageResponse("Failed to create dependent: " + e.getMessage(), "error"));
        }
    }
    
    @GetMapping("/employee/{employeeId}")
    @PreAuthorize("hasRole('TD') or hasRole('GD')")
    public ResponseEntity<?> getDependentsByEmployee(@PathVariable Long employeeId) {
        try {
            List<Dependent> dependents = dependentService.getDependentsByEmployeeId(employeeId);
            return ResponseEntity.ok(new MessageResponse("Dependents retrieved successfully", "success", dependents));
            
        } catch (Exception e) {
            return ResponseEntity.badRequest()
                .body(new MessageResponse("Failed to retrieve dependents: " + e.getMessage(), "error"));
        }
    }
    
    @GetMapping("/employee/{employeeId}/relationship/{relationship}")
    @PreAuthorize("hasRole('TD') or hasRole('GD')")
    public ResponseEntity<?> getDependentsByEmployeeAndRelationship(
            @PathVariable Long employeeId, 
            @PathVariable RelationshipType relationship) {
        try {
            List<Dependent> dependents = dependentService.getDependentsByEmployeeAndRelationship(employeeId, relationship);
            return ResponseEntity.ok(new MessageResponse("Dependents retrieved successfully", "success", dependents));
            
        } catch (Exception e) {
            return ResponseEntity.badRequest()
                .body(new MessageResponse("Failed to retrieve dependents: " + e.getMessage(), "error"));
        }
    }
    
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('TD') or hasRole('GD')")
    public ResponseEntity<?> getDependentById(@PathVariable Long id) {
        try {
            Dependent dependent = dependentService.getDependentById(id);
            return ResponseEntity.ok(new MessageResponse("Dependent retrieved successfully", "success", dependent));
            
        } catch (Exception e) {
            return ResponseEntity.badRequest()
                .body(new MessageResponse("Dependent not found: " + e.getMessage(), "error"));
        }
    }
    
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('TD') or hasRole('GD')")
    public ResponseEntity<?> updateDependent(
            @PathVariable Long id,
            @ModelAttribute Dependent dependentDetails,
            @RequestParam(value = "birthCertificate", required = false) MultipartFile birthCertificate,
            @RequestParam(value = "photo", required = false) MultipartFile photo,
            @RequestParam(value = "identityProof", required = false) MultipartFile identityProof,
            @RequestParam(value = "medicalCertificate", required = false) MultipartFile medicalCertificate) {
        
        try {
            Map<String, MultipartFile> attachments = new HashMap<>();
            
            if (birthCertificate != null && !birthCertificate.isEmpty()) {
                attachments.put("birthCertificate", birthCertificate);
            }
            if (photo != null && !photo.isEmpty()) {
                attachments.put("photo", photo);
            }
            if (identityProof != null && !identityProof.isEmpty()) {
                attachments.put("identityProof", identityProof);
            }
            if (medicalCertificate != null && !medicalCertificate.isEmpty()) {
                attachments.put("medicalCertificate", medicalCertificate);
            }
            
            Dependent updatedDependent = dependentService.updateDependentWithAttachments(id, dependentDetails, attachments);
            return ResponseEntity.ok(new MessageResponse("Dependent updated successfully", "success", updatedDependent));
            
        } catch (Exception e) {
            return ResponseEntity.badRequest()
                .body(new MessageResponse("Failed to update dependent: " + e.getMessage(), "error"));
        }
    }
    
    @PostMapping("/{id}/attachment/{attachmentType}")
    @PreAuthorize("hasRole('TD') or hasRole('GD')")
    public ResponseEntity<?> updateDependentAttachment(
            @PathVariable Long id,
            @PathVariable String attachmentType,
            @RequestParam("file") MultipartFile file) {
        
        try {
            Dependent updatedDependent = dependentService.updateDependentAttachment(id, attachmentType, file);
            return ResponseEntity.ok(new MessageResponse("Attachment updated successfully", "success", updatedDependent));
            
        } catch (Exception e) {
            return ResponseEntity.badRequest()
                .body(new MessageResponse("Failed to update attachment: " + e.getMessage(), "error"));
        }
    }
    
    @DeleteMapping("/{id}/attachment/{attachmentType}")
    @PreAuthorize("hasRole('TD') or hasRole('GD')")
    public ResponseEntity<?> deleteDependentAttachment(
            @PathVariable Long id,
            @PathVariable String attachmentType) {
        
        try {
            dependentService.deleteDependentAttachment(id, attachmentType);
            return ResponseEntity.ok(new MessageResponse("Attachment deleted successfully", "success"));
            
        } catch (Exception e) {
            return ResponseEntity.badRequest()
                .body(new MessageResponse("Failed to delete attachment: " + e.getMessage(), "error"));
        }
    }
    
    @GetMapping("/{id}/attachment/{attachmentType}/download")
    @PreAuthorize("hasRole('TD') or hasRole('GD')")
    public ResponseEntity<ByteArrayResource> downloadDependentAttachment(
            @PathVariable Long id,
            @PathVariable String attachmentType) {
        
        try {
            byte[] fileData = dependentService.downloadDependentAttachment(id, attachmentType);
            ByteArrayResource resource = new ByteArrayResource(fileData);
            
            return ResponseEntity.ok()
                .header(HttpHeaders.CONTENT_DISPOSITION, 
                       "attachment; filename=\"" + attachmentType + "_" + id + ".pdf\"")
                .contentType(MediaType.APPLICATION_OCTET_STREAM)
                .contentLength(fileData.length)
                .body(resource);
                
        } catch (Exception e) {
            return ResponseEntity.notFound().build();
        }
    }
    
    @GetMapping("/{id}/attachments")
    @PreAuthorize("hasRole('TD') or hasRole('GD')")
    public ResponseEntity<?> getDependentAttachments(@PathVariable Long id) {
        try {
            Map<String, String> attachments = dependentService.getDependentAttachments(id);
            return ResponseEntity.ok(new MessageResponse("Attachments retrieved successfully", "success", attachments));
            
        } catch (Exception e) {
            return ResponseEntity.badRequest()
                .body(new MessageResponse("Failed to retrieve attachments: " + e.getMessage(), "error"));
        }
    }
    
    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('TD') or hasRole('GD')")
    public ResponseEntity<?> deleteDependent(@PathVariable Long id) {
        try {
            dependentService.deleteDependent(id);
            return ResponseEntity.ok(new MessageResponse("Dependent deleted successfully", "success"));
            
        } catch (Exception e) {
            return ResponseEntity.badRequest()
                .body(new MessageResponse("Failed to delete dependent: " + e.getMessage(), "error"));
        }
    }
    
    @GetMapping("/employee/{employeeId}/count")
    @PreAuthorize("hasRole('TD') or hasRole('GD')")
    public ResponseEntity<?> getDependentCount(@PathVariable Long employeeId) {
        try {
            Long count = dependentService.getDependentCountByEmployeeId(employeeId);
            Map<String, Long> response = Map.of("count", count);
            return ResponseEntity.ok(new MessageResponse("Dependent count retrieved", "success", response));
            
        } catch (Exception e) {
            return ResponseEntity.badRequest()
                .body(new MessageResponse("Failed to get dependent count: " + e.getMessage(), "error"));
        }
    }
}
```

## Usage Examples

### 1. Create Employee with Dependents
```bash
curl -X POST http://localhost:8080/api/employees \
  -H "Authorization: Bearer YOUR_JWT_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "empCode": "EMP001",
    "firstName": "John",
    "lastName": "Doe", 
    "email": "john.doe@example.com",
    "phone": "1234567890",
    "department": "IT",
    "designation": "Software Engineer",
    "dependents": [
      {
        "name": "Jane Doe",
        "relationship": "SPOUSE",
        "dateOfBirth": "1990-05-15",
        "gender": "FEMALE",
        "isNominee": true
      },
      {
        "name": "Johnny Doe",
        "relationship": "CHILD", 
        "dateOfBirth": "2015-03-10",
        "gender": "MALE"
      }
    ]
  }'
```

### 2. Add Dependent with Attachments
```bash
curl -X POST http://localhost:8080/api/dependents/employee/1 \
  -H "Authorization: Bearer YOUR_JWT_TOKEN" \
  -F "name=Alice Doe" \
  -F "relationship=CHILD" \
  -F "dateOfBirth=2018-07-20" \
  -F "gender=FEMALE" \
  -F "birthCertificate=@birth_cert.pdf" \
  -F "photo=@child_photo.jpg"
```

### 3. Update Employee with Dependents
```bash
curl -X PUT http://localhost:8080/api/employees/1/with-dependents \
  -H "Authorization: Bearer YOUR_JWT_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "firstName": "John Updated",
    "lastName": "Doe",
    "email": "john.updated@example.com",
    "phone": "0987654321",
    "department": "IT",
    "designation": "Senior Software Engineer",
    "dependents": [
      {
        "id": 1,
        "name": "Jane Updated",
        "relationship": "SPOUSE",
        "dateOfBirth": "1990-05-15",
        "gender": "FEMALE",
        "isNominee": true
      },
      {
        "name": "New Child",
        "relationship": "CHILD",
        "dateOfBirth": "2020-01-01",
        "gender": "MALE"
      }
    ]
  }'
```

### 4. Get Employee with Dependents
```bash
curl -X GET http://localhost:8080/api/employees/1/with-dependents \
  -H "Authorization: Bearer YOUR_JWT_TOKEN"
```

### 5. Update Dependent Attachment
```bash
curl -X POST http://localhost:8080/api/dependents/1/attachment/photo \
  -H "Authorization: Bearer YOUR_JWT_TOKEN" \
  -F "file=@new_photo.jpg"
```

### 6. Download Dependent Attachment
```bash
curl -X GET http://localhost:8080/api/dependents/1/attachment/birthCertificate/download \
  -H "Authorization: Bearer YOUR_JWT_TOKEN" \
  --output birth_certificate.pdf
```

## Key Features

1. **One-to-Many Relationship**: Employee can have multiple dependents
2. **Cascade Operations**: Deleting employee removes all dependents
3. **Orphan Removal**: Removing dependent from list deletes it from database  
4. **File Attachments**: Each dependent can have multiple file attachments
5. **Batch Updates**: Update employee and all dependents in single operation
6. **Individual Updates**: Update specific dependent or attachment independently
7. **Relationship Filtering**: Get dependents by specific relationship type
8. **File Management**: Upload, update, delete, and download attachments
9. **Transaction Management**: All operations are transactional
10. **Validation**: Proper error handling and validation
==============================================================
# Complete Explanation of One-to-Many Relationship with File Attachments

## Overview

This is a comprehensive example demonstrating a **One-to-Many relationship** between **Employee** and **Dependents** entities, with integrated file attachment management. Here's a detailed breakdown:

## 1. Relationship Structure

### One-to-Many Concept
- **One Employee** can have **Many Dependents** (spouse, children, parents)
- **One Dependent** belongs to **only One Employee**
- This creates a parent-child relationship in the database

### Database Design
```
employees (1) ←→ (many) dependents
     ↓                    ↓
   emp_id              employee_id (foreign key)
```

## 2. Entity Relationship Mapping

### Employee Entity (Parent/One Side)
```java
@OneToMany(mappedBy = "employee", cascade = CascadeType.ALL, fetch = FetchType.LAZY, orphanRemoval = true)
@JsonManagedReference
private List<Dependent> dependents = new ArrayList<>();
```

**Key Annotations Explained:**
- `@OneToMany`: Defines one-to-many relationship
- `mappedBy = "employee"`: References the `employee` field in Dependent entity
- `cascade = CascadeType.ALL`: Operations on Employee cascade to Dependents
- `fetch = FetchType.LAZY`: Dependents loaded only when accessed
- `orphanRemoval = true`: Dependents removed from list are deleted from database
- `@JsonManagedReference`: Prevents infinite JSON recursion

### Dependent Entity (Child/Many Side)
```java
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "employee_id", nullable = false)
@JsonBackReference
private Employee employee;
```

**Key Annotations Explained:**
- `@ManyToOne`: Defines many-to-one relationship
- `@JoinColumn`: Specifies foreign key column name
- `nullable = false`: Employee reference is mandatory
- `@JsonBackReference`: Complements @JsonManagedReference to prevent recursion

## 3. Cascade Operations

### What Cascade Means
When you perform operations on the parent (Employee), they automatically apply to children (Dependents):

```java
// Save employee with dependents
Employee emp = new Employee("EMP001", "John", "Doe", "john@example.com");
emp.addDependent(new Dependent("Jane", RelationshipType.SPOUSE));
emp.addDependent(new Dependent("Johnny", RelationshipType.CHILD));
employeeRepository.save(emp); // Saves employee AND all dependents
```

### Types of Cascade Operations
- **PERSIST**: Saving employee saves dependents
- **MERGE**: Updating employee updates dependents  
- **REMOVE**: Deleting employee deletes dependents
- **REFRESH**: Refreshing employee refreshes dependents
- **ALL**: Includes all above operations

## 4. File Attachment Integration

### Attachment Storage Strategy
Each dependent can have multiple file attachments stored as database columns:

```java
// Attachment columns in Dependent entity
private String birthCertificate;    // File path
private String photo;               // File path  
private String identityProof;       // File path
private String medicalCertificate;  // File path
```

### File Storage Architecture
```
Database: Stores file paths/names
    ↓
File Server: Stores actual files
    ↓
Directory Structure: /uploads/DEPENDENT/2025/08/dependentId/filename
```

## 5. CRUD Operations Explained

### Create Operations

#### Create Employee with Dependents
```java
public Employee saveEmployeeWithDependents(Employee employee) {
    // 1. Save employee first to get ID
    Employee savedEmployee = employeeRepository.save(employee);
    
    // 2. Set employee reference for all dependents
    if (employee.getDependents() != null) {
        for (Dependent dependent : employee.getDependents()) {
            dependent.setEmployee(savedEmployee); // Set foreign key
        }
        dependentRepository.saveAll(employee.getDependents()); // Save all dependents
    }
    
    return savedEmployee;
}
```

#### Create Dependent with Attachments
```java
public Dependent saveDependentWithAttachments(Long employeeId, Dependent dependent, 
                                            Map<String, MultipartFile> attachments) {
    // 1. Find parent employee
    Employee employee = employeeRepository.findById(employeeId)
        .orElseThrow(() -> new RuntimeException("Employee not found"));
    
    // 2. Set relationship
    dependent.setEmployee(employee);
    
    // 3. Save dependent to get ID
    Dependent savedDependent = dependentRepository.save(dependent);
    
    // 4. Process file attachments
    if (attachments != null) {
        for (Map.Entry<String, MultipartFile> entry : attachments.entrySet()) {
            String attachmentType = entry.getKey();
            MultipartFile file = entry.getValue();
            
            // Store file on file server
            String filePath = fileStorageService.storeFile(file, "DEPENDENT", 
                                                         savedDependent.getId(), attachmentType);
            
            // Update appropriate database column
            updateAttachmentField(savedDependent, attachmentType, filePath);
        }
        
        // Save again with attachment paths
        savedDependent = dependentRepository.save(savedDependent);
    }
    
    return savedDependent;
}
```

### Update Operations

#### Update Employee with Dependents (Full Replace)
```java
public Employee updateEmployeeWithDependents(Long employeeId, Employee employeeDetails) {
    // 1. Find existing employee with dependents
    Employee existingEmployee = employeeRepository.findByIdWithDependents(employeeId)
        .orElseThrow(() -> new RuntimeException("Employee not found"));
    
    // 2. Update employee fields
    existingEmployee.setFirstName(employeeDetails.getFirstName());
    existingEmployee.setLastName(employeeDetails.getLastName());
    // ... other fields
    
    // 3. Replace dependents completely
    existingEmployee.getDependents().clear(); // Triggers orphan removal
    
    if (employeeDetails.getDependents() != null) {
        for (Dependent newDependent : employeeDetails.getDependents()) {
            newDependent.setEmployee(existingEmployee);
            existingEmployee.addDependent(newDependent);
        }
    }
    
    return employeeRepository.save(existingEmployee);
}
```

#### Update Individual Dependent
```java
public Dependent updateDependent(Long dependentId, Dependent dependentDetails) {
    // Find existing dependent
    Dependent existingDependent = dependentRepository.findById(dependentId)
        .orElseThrow(() -> new RuntimeException("Dependent not found"));
    
    // Update only the fields that changed
    existingDependent.setName(dependentDetails.getName());
    existingDependent.setRelationship(dependentDetails.getRelationship());
    existingDependent.setDateOfBirth(dependentDetails.getDateOfBirth());
    // ... other fields
    
    // Employee relationship remains unchanged
    return dependentRepository.save(existingDependent);
}
```

### Read Operations

#### Fetch Employee with Dependents (Eager Loading)
```java
@Query("SELECT e FROM Employee e LEFT JOIN FETCH e.dependents WHERE e.id = :id")
Optional<Employee> findByIdWithDependents(@Param("id") Long id);
```

**Explanation:**
- `LEFT JOIN FETCH`: Loads dependents in single query (avoids N+1 problem)
- Without FETCH: Would require separate query for each dependent
- `LEFT JOIN`: Includes employees even if they have no dependents

#### Filter Dependents by Relationship
```java
List<Dependent> findByEmployeeIdAndRelationship(Long employeeId, RelationshipType relationship);
```

### Delete Operations

#### Delete Employee (Cascades to Dependents)
```java
public void deleteEmployee(Long id) {
    // This automatically deletes all dependents due to cascade=ALL
    employeeRepository.deleteById(id);
}
```

#### Delete Individual Dependent
```java
public void deleteDependent(Long id) {
    Dependent dependent = dependentRepository.findById(id)
        .orElseThrow(() -> new RuntimeException("Dependent not found"));
    
    // 1. Delete associated files first
    try {
        if (dependent.getBirthCertificate() != null) {
            fileStorageService.deleteFile(dependent.getBirthCertificate());
        }
        // ... delete other attachments
    } catch (IOException e) {
        // Log error but continue
    }
    
    // 2. Delete dependent record
    dependentRepository.deleteById(id);
}
```

## 6. File Management Integration

### File Storage Process
```java
private void updateAttachmentField(Dependent dependent, String attachmentType, String filePath) {
    switch (attachmentType.toLowerCase()) {
        case "birthcertificate":
            dependent.setBirthCertificate(filePath);
            break;
        case "photo":
            dependent.setPhoto(filePath);
            break;
        case "identityproof":
            dependent.setIdentityProof(filePath);
            break;
        case "medicalcertificate":
            dependent.setMedicalCertificate(filePath);
            break;
    }
}
```

### File Path Generation
```
Pattern: /uploads/DEPENDENT/YYYY/MM/dependentId/uniqueFilename.ext
Example: /uploads/DEPENDENT/2025/08/123/birth_cert_1693456789_abc12345.pdf
```

## 7. Transaction Management

### Why Transactions Matter
```java
@Transactional  // Ensures all operations succeed or all fail
public Employee updateEmployeeWithDependents(Long employeeId, Employee employeeDetails) {
    // If any operation fails, entire transaction rolls back
    // 1. Update employee
    // 2. Delete old dependents  
    // 3. Add new dependents
    // 4. Save changes
}
```

## 8. API Design Patterns

### RESTful Endpoints
```
POST   /api/employees                    # Create employee
GET    /api/employees/{id}/with-dependents # Get employee with dependents
PUT    /api/employees/{id}/with-dependents # Update employee with dependents
POST   /api/dependents/employee/{id}     # Add dependent to employee
PUT    /api/dependents/{id}              # Update specific dependent
DELETE /api/dependents/{id}              # Delete specific dependent
```

### Request/Response Patterns

#### Create Request (JSON + Files)
```bash
# Using multipart form data for files
curl -X POST /api/dependents/employee/1 \
  -F "name=John Jr" \
  -F "relationship=CHILD" \
  -F "birthCertificate=@cert.pdf" \
  -F "photo=@photo.jpg"
```

#### Update Response (JSON)
```json
{
  "message": "Dependent updated successfully",
  "status": "success", 
  "data": {
    "id": 1,
    "name": "John Jr Updated",
    "relationship": "CHILD",
    "birthCertificate": "/uploads/DEPENDENT/2025/08/1/cert_123.pdf",
    "photo": "/uploads/DEPENDENT/2025/08/1/photo_456.jpg"
  }
}
```

## 9. Performance Considerations

### N+1 Query Problem
```java
// BAD: This creates N+1 queries
List<Employee> employees = employeeRepository.findAll();
for (Employee emp : employees) {
    System.out.println(emp.getDependents().size()); // Triggers separate query per employee
}

// GOOD: Use fetch join or batch loading
@Query("SELECT e FROM Employee e LEFT JOIN FETCH e.dependents")
List<Employee> findAllWithDependents();
```

### Lazy Loading Strategy
```java
@OneToMany(fetch = FetchType.LAZY) // Default - loads dependents only when accessed
vs
@OneToMany(fetch = FetchType.EAGER) // Always loads dependents with employee
```

## 10. Error Handling Strategies

### Constraint Violations
```java
try {
    employee.addDependent(dependent);
    employeeRepository.save(employee);
} catch (DataIntegrityViolationException e) {
    throw new RuntimeException("Dependent validation failed: " + e.getMessage());
}
```

### File Operations
```java
try {
    String filePath = fileStorageService.storeFile(file, "DEPENDENT", dependentId, "photo");
    dependent.setPhoto(filePath);
} catch (IOException e) {
    // Clean up partial operations
    dependentRepository.delete(dependent);
    throw new RuntimeException("File upload failed: " + e.getMessage());
}
```

## 11. Security Considerations

### Role-Based Access
```java
@PreAuthorize("hasRole('TD') or hasRole('GD')")
public ResponseEntity<?> updateDependent(@PathVariable Long id, @RequestBody Dependent dependent) {
    // Only TD or GD roles can update dependents
}
```

### File Type Validation
```java
private static final String[] ALLOWED_EXTENSIONS = {".pdf", ".doc", ".docx", ".jpg", ".jpeg", ".png"};

private void validateFile(MultipartFile file) {
    String extension = getFileExtension(file.getOriginalFilename());
    if (!Arrays.asList(ALLOWED_EXTENSIONS).contains(extension)) {
        throw new IllegalArgumentException("File type not allowed: " + extension);
    }
}
```

## 12. Benefits of This Approach

### Data Integrity
- Foreign key constraints ensure referential integrity
- Cascade operations maintain consistency
- Transactions ensure atomicity

### Performance
- Lazy loading reduces memory usage
- Fetch joins prevent N+1 queries
- Indexed foreign keys improve query performance

### Maintainability
- Clean separation of concerns
- Consistent API patterns
- Comprehensive error handling

### Flexibility
- Independent dependent management
- Individual file operations
- Batch and single operations supported

This architecture provides a robust, scalable solution for managing one-to-many relationships with file attachments while maintaining data integrity, performance, and security.

This example demonstrates a complete one-to-many relationship with file attachments, including all CRUD operations and file management capabilities.


